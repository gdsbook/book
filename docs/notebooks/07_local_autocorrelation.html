
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Local Spatial Autocorrelation &#8212; Geographic Data Science with Python</title>
    
  <link href="../_static/css/theme.css" rel="stylesheet">
  <link href="../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/sphinx-book-theme.d59cb220de22ca1c485ebbdc042f0030.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="canonical" href="https://geographicdata.science/book/notebooks/07_local_autocorrelation.html" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Point Pattern Analysis" href="08_point_pattern_analysis.html" />
    <link rel="prev" title="Global Spatial Autocorrelation" href="06_spatial_autocorrelation.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
<script async="" src="https://www.google-analytics.com/analytics.js"></script>
<script>
                        window.ga = window.ga || function () {
                            (ga.q = ga.q || []).push(arguments) };
                        ga.l = +new Date;
                        ga('create', 'UA-146598819-1', 'auto');
                        ga('set', 'anonymizeIp', true);
                        ga('send', 'pageview');
                    </script>

  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Geographic Data Science with Python</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../intro.html">
   Home
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Preface
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="00_toc.html">
   Table of Contents
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Part I - Building Blocks
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../intro_part_i.html">
   Overview
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="01_geo_thinking.html">
   Geographic thinking for data scientists
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="02_geospatial_computational_environment.html">
   Computational Tools for Geographic Data Science
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="03_spatial_data.html">
   Spatial Data
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="04_spatial_weights.html">
   Spatial Weights
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Part II - Spatial Data Analysis
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../intro_part_ii.html">
   Overview
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="05_choropleth.html">
   Choropleth Mapping
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="06_spatial_autocorrelation.html">
   Global Spatial Autocorrelation
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Local Spatial Autocorrelation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="08_point_pattern_analysis.html">
   Point Pattern Analysis
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Part III - Advanced Topics
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../intro_part_iii.html">
   Overview
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="09_spatial_inequality.html">
   Spatial Inequality Dynamics
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="10_clustering_and_regionalization.html">
   Clustering &amp; Regionalization
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="11_regression.html">
   Spatial Regression
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="12_feature_engineering.html">
   Spatial Feature Engineering
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Endmatter
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="references.html">
   References
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Datasets
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../data/README.html">
   Overview
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../data/airbnb/regression_cleaning.html">
   AirBnb
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../data/airports/airports_cleaning.html">
   Airports
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../data/brexit/brexit_cleaning.html">
   Brexit
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../data/countries/countries_cleaning.html">
   Countries
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../data/ghsl/build_ghsl_extract.html">
   GHSL
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../data/h3_grid/build_sd_h3_grid.html">
   H3 Grid
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../data/mexico/README.html">
   Mexico
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../data/nasadem/build_nasadem_sd.html">
   NASA DEM
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../data/sandiego/sandiego_tracts_cleaning.html">
   San Diego Tracts
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../data/texas/README.html">
   Texas
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../data/tokyo/tokyo_cleaning.html">
   Tokyo Photographs
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../data/us_county_income/README.html">
   US County Income 1969-2017
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../_sources/notebooks/07_local_autocorrelation.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
                onclick="printPdf(this)" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/gdsbook/book/master?urlpath=lab/tree/notebooks/07_local_autocorrelation.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="../_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        <a class="colab-button" href="https://colab.research.google.com/github/gdsbook/book/blob/master/notebooks/07_local_autocorrelation.ipynb"><button type="button" class="btn btn-secondary topbarbtn"
                title="Launch Colab" data-toggle="tooltip" data-placement="left"><img class="colab-button-logo"
                    src="../_static/images/logo_colab.png"
                    alt="Interact on Colab">Colab</button></a>
        
        
    </div>
</div>

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show noprint">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#an-empirical-illustration-the-eu-referendum">
   An empirical illustration: the EU Referendum
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#motivating-local-spatial-autocorrelation">
   Motivating Local Spatial Autocorrelation
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#local-moran-s-i-i">
   Local Moran’s
   <span class="math notranslate nohighlight">
    \(I_i\)
   </span>
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#getis-and-ord-s-local-statistics">
   Getis and Ord’s local statistics
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#bonus-local-statistics-on-surfaces">
   Bonus: local statistics on surfaces
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#conclusion">
   Conclusion
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#questions">
   Questions
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#next-steps">
   Next Steps
  </a>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Local Spatial Autocorrelation</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#an-empirical-illustration-the-eu-referendum">
   An empirical illustration: the EU Referendum
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#motivating-local-spatial-autocorrelation">
   Motivating Local Spatial Autocorrelation
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#local-moran-s-i-i">
   Local Moran’s
   <span class="math notranslate nohighlight">
    \(I_i\)
   </span>
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#getis-and-ord-s-local-statistics">
   Getis and Ord’s local statistics
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#bonus-local-statistics-on-surfaces">
   Bonus: local statistics on surfaces
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#conclusion">
   Conclusion
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#questions">
   Questions
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#next-steps">
   Next Steps
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            
              <div>
                
  <div class="tex2jax_ignore mathjax_ignore section" id="local-spatial-autocorrelation">
<h1>Local Spatial Autocorrelation<a class="headerlink" href="#local-spatial-autocorrelation" title="Permalink to this headline">¶</a></h1>
<p>In the previous chapter, we explored how global measures of spatial autocorrelation can help us determine whether the overall spatial distribution of our phenomenon of interest is compatible with a geographically random process. These statistics are useful: the presence of spatial autocorrelation has important implications for subsequent statistical analysis. From a substantive perspective, spatial autocorrelation could reflect the operation of processes that generate association between the values in nearby locations. This could represent <em>spillovers</em>, where outcomes at one site influence other sites; or could indicate <em>contagion</em>, where outcomes at one site <em>causally influence</em> other sites. As we will see later in <a class="reference internal" href="11_regression.html"><span class="doc std std-doc">Chapter 11</span></a>, it could simply be the result of systematic spatial variation (or, as we will call it then, <em>heterogeneity</em>). Spatial autocorrelation also sometimes arises from data measurement and processing. In this case, the dependence is a form of non-random noise rather than due to substantive processes. For example, when “down-sampling” geographic data, sometimes large patches of identical values can be created. These may only be artifacts of the interpolation, rather than substantive autocorrelation. Regardless of whether the spatial autocorrelation is due to substantive or nuisance sources, it is a form of non-randomness that complicates statistical analysis. For these reasons, the ability to determine whether spatial autocorrelation is present in a geographically referenced data set is a critical component of the geographic data science toolbox.</p>
<p>Despite their importance, global measures of spatial autocorrelation are “whole map” statistics. They provide a single summary for an entire data set. For example,
Moran’s <span class="math notranslate nohighlight">\(I\)</span> is a good tool to summarize a dataset into a single value that captures the degree of geographical clustering (or dispersion, if negative). However, Moran’s <span class="math notranslate nohighlight">\(I\)</span> does not indicate areas within the map where specific types of values (e.g. high, low) are clustered, or instances of explicit dispersion.
In other words, Moran’s I can tell us whether values in our map <em>cluster</em> together (or disperse) overall, but it will not inform us about where specific <em>clusters</em> (or outliers) are.</p>
<p>In this chapter, we introduce local measures of spatial autocorrelation.
Local measures of spatial autocorrelation focus on the relationships between <em>each</em> observation and its surroundings, rather than providing a single summary of these relationships across the map. In this sense, they are not summary statistics but scores that allow us to learn more about the spatial structure in our data. The general intuition behind the metrics however is similar to that of global ones. Some of them are even mathematically connected, where the global version can be decomposed into a collection of local ones. One such example are Local Indicators of Spatial Association (LISAs) <span id="id1">[<a class="reference internal" href="references.html#id2" title="Luc Anselin. Local indicators of spatial association-LISA. Geographical Analysis, 27:93–115, 1995.">Ans95</a>]</span>, which we use to build the understanding of local spatial autocorrelation, and on which we spend a good part of the chapter. Once such concepts are firmed, we introduce a couple alternative statistics that present complementary information or allow us to obtain similar insights for categorical data. Although very often these statistics are used with data expressed in geo-tables, there is nothing fundamentally connecting the two. In fact, the application of these methods to large surfaces is a promising area of work. For that reason, we close the chapter with an illustration of how one can run these statistics on data stored as surfaces.</p>
<div class="section" id="an-empirical-illustration-the-eu-referendum">
<h2>An empirical illustration: the EU Referendum<a class="headerlink" href="#an-empirical-illustration-the-eu-referendum" title="Permalink to this headline">¶</a></h2>
<p>We continue with the same dataset about Brexit voting that we examined in the previous chapter, and thus we utilize the same imports and initial data preparation steps:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>  <span class="c1"># Graphics</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">colors</span>
<span class="kn">import</span> <span class="nn">seaborn</span>                   <span class="c1"># Graphics</span>
<span class="kn">import</span> <span class="nn">geopandas</span>                 <span class="c1"># Spatial data manipulation</span>
<span class="kn">import</span> <span class="nn">pandas</span>                    <span class="c1"># Tabular data manipulation</span>
<span class="kn">import</span> <span class="nn">rioxarray</span>                 <span class="c1"># Surface data manipulation</span>
<span class="kn">import</span> <span class="nn">xarray</span>                    <span class="c1"># Surface data manipulation</span>
<span class="kn">from</span> <span class="nn">pysal.explore</span> <span class="kn">import</span> <span class="n">esda</span>   <span class="c1"># Exploratory Spatial analytics</span>
<span class="kn">from</span> <span class="nn">pysal.lib</span> <span class="kn">import</span> <span class="n">weights</span>    <span class="c1"># Spatial weights</span>
<span class="kn">import</span> <span class="nn">contextily</span>                <span class="c1"># Background tiles</span>
</pre></div>
</div>
</div>
</div>
<p>We read the vote data as a non-spatial table:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ref</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span>
    <span class="s1">&#39;../data/brexit/brexit_vote.csv&#39;</span><span class="p">,</span> 
    <span class="n">index_col</span><span class="o">=</span><span class="s1">&#39;Area_Code&#39;</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>And the spatial geometries for the local authority districts in Great Britain:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">lads</span> <span class="o">=</span> <span class="n">geopandas</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span>
    <span class="s2">&quot;../data/brexit/local_authority_districts.geojson&quot;</span>
<span class="p">)</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;lad16cd&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Then, we “trim” the <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> so it retains only what we know we will need, reproject it to spherical mercator, and drop rows with missing data:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">db</span> <span class="o">=</span> <span class="n">geopandas</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span>
    <span class="n">lads</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ref</span><span class="p">[[</span><span class="s1">&#39;Pct_Leave&#39;</span><span class="p">]]),</span> <span class="n">crs</span><span class="o">=</span><span class="n">lads</span><span class="o">.</span><span class="n">crs</span>
<span class="p">)</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span>
    <span class="n">epsg</span><span class="o">=</span><span class="mi">3857</span>
<span class="p">)[</span>
    <span class="p">[</span><span class="s1">&#39;objectid&#39;</span><span class="p">,</span> <span class="s1">&#39;lad16nm&#39;</span><span class="p">,</span> <span class="s1">&#39;Pct_Leave&#39;</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]</span>
<span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>

<span class="n">db</span><span class="o">.</span><span class="n">info</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;class &#39;geopandas.geodataframe.GeoDataFrame&#39;&gt;
Index: 380 entries, E06000001 to W06000023
Data columns (total 4 columns):
 #   Column     Non-Null Count  Dtype   
---  ------     --------------  -----   
 0   objectid   380 non-null    int64   
 1   lad16nm    380 non-null    object  
 2   Pct_Leave  380 non-null    float64 
 3   geometry   380 non-null    geometry
dtypes: float64(1), geometry(1), int64(1), object(1)
memory usage: 14.8+ KB
</pre></div>
</div>
</div>
</div>
<p>Although there are several variables that could be considered, we will focus on <code class="docutils literal notranslate"><span class="pre">Pct_Leave</span></code>, which measures the proportion of votes in the UK Local Authority that wanted to Leave the European Union. With these elements, we can generate a choropleth to get a quick sense of the spatial distribution of the data we will be analyzing. Note how we use some visual tweaks (e.g., transparency through the <code class="docutils literal notranslate"><span class="pre">alpha</span></code> attribute) to make the final plot easier to read.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set up figure and a single axis</span>
<span class="n">f</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">))</span>
<span class="c1"># Build choropleth</span>
<span class="n">db</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
    <span class="n">column</span><span class="o">=</span><span class="s1">&#39;Pct_Leave&#39;</span><span class="p">,</span> 
    <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;viridis&#39;</span><span class="p">,</span> 
    <span class="n">scheme</span><span class="o">=</span><span class="s1">&#39;quantiles&#39;</span><span class="p">,</span>
    <span class="n">k</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> 
    <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">,</span> 
    <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> 
    <span class="n">alpha</span><span class="o">=</span><span class="mf">0.75</span><span class="p">,</span> 
    <span class="n">legend</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">legend_kwds</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span>
    <span class="n">ax</span><span class="o">=</span><span class="n">ax</span>
<span class="p">)</span>
<span class="c1"># Add basemap</span>
<span class="n">contextily</span><span class="o">.</span><span class="n">add_basemap</span><span class="p">(</span>
    <span class="n">ax</span><span class="p">,</span> 
    <span class="n">crs</span><span class="o">=</span><span class="n">db</span><span class="o">.</span><span class="n">crs</span><span class="p">,</span> 
    <span class="n">source</span><span class="o">=</span><span class="n">contextily</span><span class="o">.</span><span class="n">providers</span><span class="o">.</span><span class="n">CartoDB</span><span class="o">.</span><span class="n">VoyagerNoLabels</span>
<span class="p">)</span>
<span class="c1"># Remove axes</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/07_local_autocorrelation_11_0.png" src="../_images/07_local_autocorrelation_11_0.png" />
</div>
</div>
<p>As in the previous chapter, we require a spatial weights matrix to implement our statistic. Here, we will use eight nearest neighbors for the sake of the example, but the discussion in the earlier chapter on weights applies in this context, and other criteria would be valid too. We also row-standardize them:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Generate W from the GeoDataFrame</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">distance</span><span class="o">.</span><span class="n">KNN</span><span class="o">.</span><span class="n">from_dataframe</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="c1"># Row-standardization</span>
<span class="n">w</span><span class="o">.</span><span class="n">transform</span> <span class="o">=</span> <span class="s1">&#39;R&#39;</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="motivating-local-spatial-autocorrelation">
<h2>Motivating Local Spatial Autocorrelation<a class="headerlink" href="#motivating-local-spatial-autocorrelation" title="Permalink to this headline">¶</a></h2>
<p>To better understand the underpinnings of local spatial autocorrelation, we return to the Moran Plot as a graphical tool. In this context, it is more intuitive to represent the data in a standardised form, as it will allow us to more easily discern a typology of spatial structure. Let us first calculate the spatial lag of our variable of interest:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">db</span><span class="p">[</span><span class="s1">&#39;w_Pct_Leave&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">spatial_lag</span><span class="o">.</span><span class="n">lag_spatial</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">db</span><span class="p">[</span><span class="s1">&#39;Pct_Leave&#39;</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<p>And their respective standardized versions, where we subtract the average and divide by the standard deviation:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">db</span><span class="p">[</span><span class="s1">&#39;Pct_Leave_std&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span> <span class="n">db</span><span class="p">[</span><span class="s1">&#39;Pct_Leave&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">db</span><span class="p">[</span><span class="s1">&#39;Pct_Leave&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="p">)</span>
<span class="n">db</span><span class="p">[</span><span class="s1">&#39;w_Pct_Leave_std&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span> <span class="n">db</span><span class="p">[</span><span class="s1">&#39;w_Pct_Leave&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">db</span><span class="p">[</span><span class="s1">&#39;Pct_Leave&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Technically speaking, creating a Moran Plot is very similar to creating any other scatter plot:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Setup the figure and axis</span>
<span class="n">f</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="c1"># Plot values</span>
<span class="n">seaborn</span><span class="o">.</span><span class="n">regplot</span><span class="p">(</span>
    <span class="n">x</span><span class="o">=</span><span class="s1">&#39;Pct_Leave_std&#39;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s1">&#39;w_Pct_Leave_std&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">db</span><span class="p">,</span> <span class="n">ci</span><span class="o">=</span><span class="kc">None</span>
<span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/07_local_autocorrelation_19_0.png" src="../_images/07_local_autocorrelation_19_0.png" />
</div>
</div>
<p>Using standardized values, we can immediately divide each variable (the percentage that voted to leave, and its spatial lag) in two groups: those with above-average leave voting, which have positive standardized values; and those with below-average leave voting, which feature negative standardized values. Applying this thinking to both the percentage to leave and its spatial lag, divides a Moran Plot in four quadrants. Each of them captures a situation based on whether a given area displays a value above the mean (high) or below (low) in either the original variable (<code class="docutils literal notranslate"><span class="pre">Pct_Leave</span></code>) or its spatial lag (<code class="docutils literal notranslate"><span class="pre">w_Pct_Leave_std</span></code>). Using this terminology, we name the four quadrants as follows: high-high (HH) for the top-right, low-high (LH) for the top-left, low-low (LL) for the bottom-left, and high-low (HL) for the bottom right. Graphically, we can capture this as follows:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Setup the figure and axis</span>
<span class="n">f</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="c1"># Plot values</span>
<span class="n">seaborn</span><span class="o">.</span><span class="n">regplot</span><span class="p">(</span>
    <span class="n">x</span><span class="o">=</span><span class="s1">&#39;Pct_Leave_std&#39;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s1">&#39;w_Pct_Leave_std&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">db</span><span class="p">,</span> <span class="n">ci</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span>
<span class="c1"># Add vertical and horizontal lines</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="c1"># Add text labels for each quadrant</span>
<span class="n">plt</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="s2">&quot;HH&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="o">-</span><span class="mi">11</span><span class="p">,</span> <span class="s2">&quot;HL&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="mf">8.0</span><span class="p">,</span> <span class="s2">&quot;LH&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="o">-</span><span class="mi">25</span><span class="p">,</span> <span class="o">-</span><span class="mf">11.0</span><span class="p">,</span> <span class="s2">&quot;LL&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="c1"># Display</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/07_local_autocorrelation_21_0.png" src="../_images/07_local_autocorrelation_21_0.png" />
</div>
</div>
</div>
<div class="section" id="local-moran-s-i-i">
<h2>Local Moran’s <span class="math notranslate nohighlight">\(I_i\)</span><a class="headerlink" href="#local-moran-s-i-i" title="Permalink to this headline">¶</a></h2>
<p>One way to look at the figure above is as a classification of each observation in the dataset depending on its value and that of its neighbors. Furthermore, this classification is exhaustive: every point is assigned a label. But remember local measures help us to identify areas of <em>unusual</em> concentration of values. Clusters will represent values of one type that are <em>unlikely</em> to appear under the assumption of spatial randomness. To know whether each location belongs to a <em>statistically significant</em> cluster of a given kind, we thus need to compare it with what we would expect if the data were allocated over space in a completely random way. However, what we are interested in is whether the strength with which the values are concentrated is unusually high. This is exactly what LISAs are designed to do. A detailed description the statistical underpinnings of LISAs is beyond the scope of this chapter. If you would like to delve deeper into the math and probability challenges arising, a good recent reference is <span id="id2">[<a class="reference internal" href="references.html#id3" title="Jeffery Sauer, Taylor Oshan, Sergio Rey, and Levi John Wolf. The importance of null hypotheses: understanding differences in local moranâ€™s under heteroskedasticity. Geographical Analysis, n/a(n/a):, 2021. URL: https://onlinelibrary.wiley.com/doi/abs/10.1111/gean.12304, arXiv:https://onlinelibrary.wiley.com/doi/pdf/10.1111/gean.12304, doi:https://doi.org/10.1111/gean.12304.">SORW21</a>]</span>. In this context, we will provide some intuition about how they work in one LISA statistic, the Local Moran’s <span class="math notranslate nohighlight">\(I_i\)</span>.</p>
<p>The core idea of a local Moran’s <span class="math notranslate nohighlight">\(I_i\)</span> is to identify cases in which the value of an observation and the average of its surroundings is either more similar (HH or LL in the scatterplot above) or dissimilar (HL, LH) than we would expect from pure chance. The mechanism to do this is similar to the one in the global Moran’s I, but applied in this case to each observation. This results in as many statistics as original observations. The formal representation of the statistic can be written as:</p>
<div class="math notranslate nohighlight">
\[
I_i = \dfrac{z_i}{m_2} \displaystyle\sum_j w_{ij} z_j \; ; \; m_2 = \dfrac{\sum_i z_i^2}{n}
\]</div>
<p>where <span class="math notranslate nohighlight">\(m_2\)</span> is the second moment (variance) of the distribution of values in the data, <span class="math notranslate nohighlight">\(z_i = y_i - \bar{y}\)</span>, <span class="math notranslate nohighlight">\(w_{i,j}\)</span> is the spatial weight for the pair of observations <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span>, and <span class="math notranslate nohighlight">\(n\)</span> is the number of observations.</p>
<p>LISAs are widely used in many fields to identify geographical clusters of values or find geographical outliers. They are a useful tool that can quickly return areas in which values are concentrated and provide suggestive evidence about the processes that might be at work. For these reasons, they have a prime place in the geographic data science toolbox. Among many other applications, LISAs have been used to identify geographical clusters of poverty <span id="id3">[<a class="reference internal" href="references.html#id21" title="Teddy Dawson, J.S. Sandoval, Vasit Sagan, and Thomas Crawford. A spatial analysis of the relationship between vegetation and poverty. ISPRS International Journal of Geo-Information, 7:83, 03 2018. doi:10.3390/ijgi7030083.">DSSC18</a>]</span>, map ethnic enclaves <span id="id4">[<a class="reference internal" href="references.html#id38" title="Ron Johnston, Michael Poulsen, and James Forrest. The intensity of ethnic residential clustering: exploring scale effects using local indicators of spatial association. Environment and Planning A, 42:874-894, 04 2010. doi:10.1068/a42181.">JPF10</a>]</span>, delineate areas of particularly high/low economic activity <span id="id5">[<a class="reference internal" href="references.html#id55" title="Víctor Torres-Preciado, Mayren Polanco-Gaytán, and Miguel Tinoco-Zermeno. Technological innovation and regional economic growth in Mexico: a spatial perspective. The Annals of Regional Science, 52(1):183-200, January 2014. URL: https://ideas.repec.org/a/spr/anresc/v52y2014i1p183-200.html, doi:10.1007/s00168-013-0581-1.">TPPGTZ14</a>]</span>, or identify clusters of contagious disease <span id="id6">[<a class="reference internal" href="references.html#id91" title="Xi Zhang, Huaxiang Rao, Yuwan Wu, Yubei Huang, and Hongji Dai. Comparison of spatiotemporal characteristics of the COVID-19 and SARS outbreaks in mainland China. BMC infectious diseases, 20(1):1–7, 2020.">ZRW+20</a>]</span>. The Local Moran’s <span class="math notranslate nohighlight">\(I_i\)</span> statistic is only one of a wide variety of LISAs that can be used on many different types of spatial data.</p>
<p>In Python, we can calculate LISAs in a very streamlined way thanks to <code class="docutils literal notranslate"><span class="pre">esda</span></code>. To compute local Moran statistics, we use the <code class="docutils literal notranslate"><span class="pre">Moran_Local</span></code> function:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">lisa</span> <span class="o">=</span> <span class="n">esda</span><span class="o">.</span><span class="n">moran</span><span class="o">.</span><span class="n">Moran_Local</span><span class="p">(</span><span class="n">db</span><span class="p">[</span><span class="s1">&#39;Pct_Leave&#39;</span><span class="p">],</span> <span class="n">w</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We need to pass the variable of interest—proportion of Leave votes in this context—and the spatial weights that describes the neighborhood relations between the different areas that make up the dataset. This creates a LISA object (<code class="docutils literal notranslate"><span class="pre">lisa</span></code>) that has a number of attributes of interest. The local indicators themselves are in the <code class="docutils literal notranslate"><span class="pre">Is</span></code> attribute and we can get a sense of their distribution using <code class="docutils literal notranslate"><span class="pre">seaborn</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Draw KDE line</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">seaborn</span><span class="o">.</span><span class="n">kdeplot</span><span class="p">(</span><span class="n">lisa</span><span class="o">.</span><span class="n">Is</span><span class="p">)</span>
<span class="c1"># Add one small bar (rug) for each observation</span>
<span class="c1"># along horizontal axis</span>
<span class="n">seaborn</span><span class="o">.</span><span class="n">rugplot</span><span class="p">(</span><span class="n">lisa</span><span class="o">.</span><span class="n">Is</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/07_local_autocorrelation_26_0.png" src="../_images/07_local_autocorrelation_26_0.png" />
</div>
</div>
<p>The figure reveals a rather skewed distribution of local Moran’s <span class="math notranslate nohighlight">\(I_i\)</span> statistics. This outcome is due to the dominance of positive forms of spatial association, implying most of the local statistic values will be positive. Here it is important to keep in mind that the high positive values arise from value similarity in space, and this can be due to either high values being next to high values <em>or</em> low values next to low values. The local <span class="math notranslate nohighlight">\(I_i\)</span> values alone cannot distinguish these two cases.</p>
<p>The values in the left tail of the density represent locations displaying negative spatial association. There are also two forms, a high value surrounded by low values, or a low value surrounded by high valued neighboring observations. And, again, the  <span class="math notranslate nohighlight">\(I_i\)</span> statistic cannot distinguish between the two cases.</p>
<p>Because of their very nature, looking at the numerical result of LISAs is not always the most useful way to exploit all the information they can provide. Remember we are calculating a statistic for every single observation in the data so, if we have many of them, it will be difficult to extract any meaningful pattern. In this context, a choropleth can help. At first glance, this may seem to suggest that a choropleth of the <span class="math notranslate nohighlight">\(I_i\)</span>  values would be a useful way to visualize the spatial distribution. We can see such map in the top-left panel of the figure below and, while it tells us whether the local association is positive (HH/LL) or negative (HL/LH), it cannot tell, for example, whether the yellow areas in Scotland are similar to those in the eastern cluster of yellow areas. Are the two experiencing similar patterns of spatial association, or is one of them HH and the other LL? Also, we know that values around zero will not be statistically significant. Which local statistics are thus significant and which ones non-significant from a statistical point of view? In other words, which ones can be considered statistical clusters and which ones mere noise?</p>
<p>To answer these questions, we need to bring in additional information that we have computed when calculating the LISA statistics. We do this in four acts. The first one we have already mentioned: a straighforward choropleth of the local statistic of each area. The other three include information on the quadrant each area is assigned into, whether the statistic is considered significant or not, and a combination of those two in a single so-called <em>cluster</em> map. A handy tool in this context is the <code class="docutils literal notranslate"><span class="pre">splot</span></code> library, part of the Pysal family, which provides a lightweight visualisation layer for spatial statistics:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">splot</span> <span class="kn">import</span> <span class="n">esda</span> <span class="k">as</span> <span class="n">esdaplot</span>
</pre></div>
</div>
</div>
</div>
<p>With all pieces in place, let’s first get busy building the figure:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set up figure and axes</span>
<span class="n">f</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>
<span class="c1"># Make the axes accessible with single indexing</span>
<span class="n">axs</span> <span class="o">=</span> <span class="n">axs</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

                    <span class="c1"># Subplot 1 #</span>
            <span class="c1"># Choropleth of local statistics</span>
<span class="c1"># Grab first axis in the figure</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="c1"># Assign new column with local statistics on-the-fly</span>
<span class="n">db</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span>
    <span class="n">Is</span><span class="o">=</span><span class="n">lisa</span><span class="o">.</span><span class="n">Is</span>
<span class="c1"># Plot choropleth of local statistics</span>
<span class="p">)</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
    <span class="n">column</span><span class="o">=</span><span class="s1">&#39;Is&#39;</span><span class="p">,</span> 
    <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;plasma&#39;</span><span class="p">,</span> 
    <span class="n">scheme</span><span class="o">=</span><span class="s1">&#39;quantiles&#39;</span><span class="p">,</span>
    <span class="n">k</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> 
    <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">,</span> 
    <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> 
    <span class="n">alpha</span><span class="o">=</span><span class="mf">0.75</span><span class="p">,</span>
    <span class="n">legend</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">ax</span><span class="o">=</span><span class="n">ax</span>
<span class="p">)</span>

                    <span class="c1"># Subplot 2 #</span>
                <span class="c1"># Quadrant categories</span>
<span class="c1"># Grab second axis of local statistics</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="c1"># Plot Quandrant colors (note to ensure all polygons are assigned a</span>
<span class="c1"># quadrant, we &quot;trick&quot; the function by setting significance level to</span>
<span class="c1"># 1 so all observations are treated as &quot;significant&quot; and thus assigned</span>
<span class="c1"># a quadrant color</span>
<span class="n">esdaplot</span><span class="o">.</span><span class="n">lisa_cluster</span><span class="p">(</span><span class="n">lisa</span><span class="p">,</span> <span class="n">db</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">);</span>

                    <span class="c1"># Subplot 3 #</span>
                <span class="c1"># Significance map</span>
<span class="c1"># Grab third axis of local statistics</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="c1"># </span>
<span class="c1"># Find out significant observations</span>
<span class="n">labels</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
    <span class="mi">1</span> <span class="o">*</span> <span class="p">(</span><span class="n">lisa</span><span class="o">.</span><span class="n">p_sim</span> <span class="o">&lt;</span> <span class="mf">0.05</span><span class="p">),</span> <span class="c1"># Assign 1 if significant, 0 otherwise</span>
    <span class="n">index</span><span class="o">=</span><span class="n">db</span><span class="o">.</span><span class="n">index</span>           <span class="c1"># Use the index in the original data</span>
<span class="c1"># Recode 1 to &quot;Significant and 0 to &quot;Non-significant&quot;</span>
<span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;Significant&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span> <span class="s1">&#39;Non-Significant&#39;</span><span class="p">})</span>
<span class="c1"># Assign labels to `db` on the fly</span>
<span class="n">db</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span>
    <span class="n">cl</span><span class="o">=</span><span class="n">labels</span>
<span class="c1"># Plot choropleth of (non-)significant areas</span>
<span class="p">)</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
    <span class="n">column</span><span class="o">=</span><span class="s1">&#39;cl&#39;</span><span class="p">,</span> 
    <span class="n">categorical</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;Paired&#39;</span><span class="p">,</span>
    <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
    <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">,</span>
    <span class="n">legend</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">ax</span><span class="o">=</span><span class="n">ax</span>
<span class="p">)</span>

                       
                    <span class="c1"># Subplot 4 #</span>
                    <span class="c1"># Cluster map</span>
<span class="c1"># Grab second axis of local statistics</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="c1"># Plot Quandrant colors In this case, we use a 5% significance</span>
<span class="c1"># level to select polygons as part of statistically significant</span>
<span class="c1"># clusters</span>
<span class="n">esdaplot</span><span class="o">.</span><span class="n">lisa_cluster</span><span class="p">(</span><span class="n">lisa</span><span class="p">,</span> <span class="n">db</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">);</span>

                    <span class="c1"># Figure styling #</span>
<span class="c1"># Set title to each subplot</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axs</span><span class="o">.</span><span class="n">flatten</span><span class="p">()):</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="s1">&#39;Local Statistics&#39;</span><span class="p">,</span> 
            <span class="s1">&#39;Scatterplot Quadrant&#39;</span><span class="p">,</span> 
            <span class="s1">&#39;Statistical Significance&#39;</span><span class="p">,</span> 
            <span class="s1">&#39;Moran Cluster Map&#39;</span>
        <span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">y</span><span class="o">=</span><span class="mi">0</span>
    <span class="p">)</span>
<span class="c1"># Tight layout to minimise in-betwee white space</span>
<span class="n">f</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

<span class="c1"># Display the figure</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/07_local_autocorrelation_31_0.png" src="../_images/07_local_autocorrelation_31_0.png" />
</div>
</div>
<p>The purple and yellow locations in the top-right map display the largest magnitude (positive and negative values) for the local statistics <span class="math notranslate nohighlight">\(I_i\)</span>. Yet, remember this signifies positive spatial autocorrelation, which can be of high <em>or</em> low values. This map thus cannot distinguish between areas with low support for the Brexit vote and those highly in favour.</p>
<p>To distinguish between these two cases, the map in the upper-right shows the location of the LISA statistic in the quadrant of the Moran Scatter plot. This indicates whether the positive (or negative) local association exists within a specific <em>quadrant</em>, such as the High-High quadrant. This information is recorded in the <code class="docutils literal notranslate"><span class="pre">q</span></code> attribute of the <code class="docutils literal notranslate"><span class="pre">lisa</span></code> object:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">lisa</span><span class="o">.</span><span class="n">q</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([1, 1, 1, 1, 1, 1, 4, 1, 4, 1])
</pre></div>
</div>
</div>
</div>
<p>The correspondence between the numbers in the <code class="docutils literal notranslate"><span class="pre">q</span></code> attribute and the actual quadrants is as follows: <code class="docutils literal notranslate"><span class="pre">1</span></code> represents observations in the HH quadrant, <code class="docutils literal notranslate"><span class="pre">2</span></code> those in the LH one, <code class="docutils literal notranslate"><span class="pre">3</span></code> in the LL region, and <code class="docutils literal notranslate"><span class="pre">4</span></code> in the HL quadrant. Comparing the two maps in the top row reveals that the positive local association in Scotland is due to low support for Brexit, while the positive local association in the south is among local authorities that strongly support Brexit. Overall, we can obtain counts of areas in each quadrant as follows:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">counts</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">value_counts</span><span class="p">(</span><span class="n">lisa</span><span class="o">.</span><span class="n">q</span><span class="p">)</span>
<span class="n">counts</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1    183
3    113
2     50
4     34
dtype: int64
</pre></div>
</div>
</div>
</div>
<p>Showing that the high-high (1), and low-low (3), values are predominant. Care must be taken, however, in the interpretation of these first two maps, as the underlying statistical significance of the local values has not been considered. We have simply mapped the raw LISA value alongside the quadrant in which the local statistic resides. To statistical significance, the bottom left map distinguishes those polygons whose pseudo p-value is above (<em>“Non-Significant”</em>) or below (<em>“Significant”</em>) the threshold value of 5% we use in this context. An examination of the map suggests that quite a few local authorities have local statistics that are small enough so as to be compatible with pure chance.</p>
<p>Therefore, in order to focus on the areas that are most promising, we need to include significance information alongside the quadrant and local statistic. Together, this “cluster map” (as it is usually called) extracts significant observations -those that are highly unlikely to have come from pure chance- and plots them with a specific color depending on their quadrant category. All of the needed pieces are contained inside the <code class="docutils literal notranslate"><span class="pre">lisa</span></code> object we have created above and, if passed in tandem with the geo-table containing the geographies it relates to, <code class="docutils literal notranslate"><span class="pre">splot</span></code> will make a cluster map for us.</p>
<p>Reading the clustermap reveals a few interesting aspects that would have been hard to grasp by looking at the other maps only and that are arguably more relevant for an analysis of the data. First, it is only less than half of polygons that have degrees of local spatial association strong enough to reject the idea of pure chance:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lisa</span><span class="o">.</span><span class="n">p_sim</span> <span class="o">&lt;</span> <span class="mf">0.05</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">lisa</span><span class="o">.</span><span class="n">p_sim</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>41.578947368421055
</pre></div>
</div>
</div>
</div>
<p>A little over 41% of the local authorities are considered, by this analysis, to be part of a spatial cluster. Second, we identify three clear areas of low support for leaving the EU: Scotland, London, and the area around Oxford (North-West of London). And third, although there appeared to be many areas with concentrated values indicating high support, it is only the region in the North-East and West of England whose spatial concentration shows enough strength to reasonably rule out pure chance.</p>
<p>Before we move on from the LISA statistics, let’s dive into a bit of the data engineering required to “export” significance levels and other information, as well as dig a bit further into what these numbers represent. The latter is useful if we need to work with them as part of a broader data pipeline. So far, cluster maps have been handled by <code class="docutils literal notranslate"><span class="pre">splot</span></code>, but there is quite a bit that happens under the hood. If we needed to recreate one of its maps, or to use this information in a different context, we would need to extract them out of our <code class="docutils literal notranslate"><span class="pre">lisa</span></code> object, and link them up to the original <code class="docutils literal notranslate"><span class="pre">db</span></code> table. Here is one way you can do this.</p>
<p>First, we pull the information computed in <code class="docutils literal notranslate"><span class="pre">lisa</span></code> and insert it in the main data table:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Assign pseudo P-values to `db`</span>
<span class="n">db</span><span class="p">[</span><span class="s1">&#39;p-sim&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lisa</span><span class="o">.</span><span class="n">p_sim</span>
<span class="c1"># `1` if significant (at 5% confidence level), `0` otherwise</span>
<span class="n">sig</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="p">(</span><span class="n">lisa</span><span class="o">.</span><span class="n">p_sim</span> <span class="o">&lt;</span> <span class="mf">0.05</span><span class="p">)</span>
<span class="c1"># Assign significance flag to `db`</span>
<span class="n">db</span><span class="p">[</span><span class="s1">&#39;sig&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sig</span>
<span class="c1"># Print top of the table to inspect</span>
<span class="n">db</span><span class="p">[[</span><span class="s1">&#39;sig&#39;</span><span class="p">,</span><span class="s1">&#39;p-sim&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>sig</th>
      <th>p-sim</th>
    </tr>
    <tr>
      <th>lad16cd</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>E06000001</th>
      <td>1</td>
      <td>0.008</td>
    </tr>
    <tr>
      <th>E06000002</th>
      <td>1</td>
      <td>0.008</td>
    </tr>
    <tr>
      <th>E06000003</th>
      <td>1</td>
      <td>0.011</td>
    </tr>
    <tr>
      <th>E06000004</th>
      <td>1</td>
      <td>0.011</td>
    </tr>
    <tr>
      <th>E06000010</th>
      <td>1</td>
      <td>0.012</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Print bottom of the table to inspect</span>
<span class="n">db</span><span class="p">[[</span><span class="s1">&#39;sig&#39;</span><span class="p">,</span><span class="s1">&#39;p-sim&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">tail</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>sig</th>
      <th>p-sim</th>
    </tr>
    <tr>
      <th>lad16cd</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>W06000018</th>
      <td>0</td>
      <td>0.498</td>
    </tr>
    <tr>
      <th>W06000019</th>
      <td>0</td>
      <td>0.487</td>
    </tr>
    <tr>
      <th>W06000021</th>
      <td>0</td>
      <td>0.475</td>
    </tr>
    <tr>
      <th>W06000022</th>
      <td>0</td>
      <td>0.353</td>
    </tr>
    <tr>
      <th>W06000023</th>
      <td>0</td>
      <td>0.278</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>Thus, the first five values are statistically significant, while the last five observations are not.</p>
<p>Let us stop for a second on these two steps. First, we consider the <code class="docutils literal notranslate"><span class="pre">sig</span></code> column. Akin to global Moran’s I, <code class="docutils literal notranslate"><span class="pre">esda</span></code> automatically computes a pseudo p-value for each LISA. Because some instances of the LISA statistics may not be statistically significant, we want to identify those with a p-value small enough that rules out the possibility of obtaining a similar value in random maps. A few different ways of generating random maps are considered by <code class="docutils literal notranslate"><span class="pre">esda</span></code>, but we focus on a strategy that actually simulates hundreds of thousands of random maps to get a rough idea of the possible local statistic values at each local authority given the data we saw. In addition, we follow a similar reasoning as with global Moran’s I and use 5% as the threshold for statistical significance. To identify these values, we create a variable, <code class="docutils literal notranslate"><span class="pre">sig</span></code>, that contains <code class="docutils literal notranslate"><span class="pre">True</span></code> if the p-value of the observation satisfies the condition, and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>Next, we construct our quadrant values using the <code class="docutils literal notranslate"><span class="pre">q</span></code> attribute which records the Moran Scatterplot quadrant for each local value. However, we now mask these values using the newly created binary significance measure <code class="docutils literal notranslate"><span class="pre">sig</span></code>, so only observations in a quadrant that are considered significant are labeled as part of that given quadrant. The remainder are labelled as non-significant.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Pick as part of a quadrant only significant polygons, </span>
<span class="c1"># assign `0` otherwise (Non-significant polygons)</span>
<span class="n">spots</span> <span class="o">=</span> <span class="n">lisa</span><span class="o">.</span><span class="n">q</span> <span class="o">*</span> <span class="n">sig</span>
<span class="c1"># Mapping from value to name (as a dict)</span>
<span class="n">spots_labels</span> <span class="o">=</span> <span class="p">{</span>
    <span class="mi">0</span><span class="p">:</span> <span class="s1">&#39;Non-Significant&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="s1">&#39;HH&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;LH&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="s1">&#39;LL&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="s1">&#39;HL&#39;</span>
<span class="p">}</span>
<span class="c1"># Create column in `db` with labels for each polygon</span>
<span class="n">db</span><span class="p">[</span><span class="s1">&#39;labels&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
    <span class="c1"># First initialise a Series using values and `db` index</span>
    <span class="n">spots</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">db</span><span class="o">.</span><span class="n">index</span>
<span class="c1"># Then map each value to corresponding label based </span>
<span class="c1"># on the `spots_labels` mapping</span>
<span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">spots_labels</span><span class="p">)</span>
<span class="c1"># Print top for inspection</span>
<span class="n">db</span><span class="p">[</span><span class="s1">&#39;labels&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>lad16cd
E06000001    HH
E06000002    HH
E06000003    HH
E06000004    HH
E06000010    HH
Name: labels, dtype: object
</pre></div>
</div>
</div>
</div>
<p>These cluster labels are meaningful if you know of the Moran Plot. To help making them a bit more intuitive, a terminology that is sometimes used goes as follows. Positive forms of local spatial autocorrelation are of two types. First, HH observations, which we can term “hot spots”, represent areas where values at the site and its surroundings are larger than average. Second, LL observations, significant clusters of low values surrounded by low values, are sometimes referred to as “cold spots”. Negative forms of local spatial autocorrelation also include two cases. When the focal observation displays low values but its surroundings have high values (LH), we call them “doughnuts”. Conversely, areas with high values but neighboured by others with low values (HL) can be referred to as “diamonds in the rough”. We note this terminology is purely mnemonic, but recognise in some cases it can help remembering the interpretation of local statistics.</p>
<p>After building these new columns, analysis on the overall trends of LISA statistics is more straightforward than from the <code class="docutils literal notranslate"><span class="pre">lisa</span></code> object. For example, an overview of the distribution of labels is one line away:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">db</span><span class="p">[</span><span class="s1">&#39;labels&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Non-Significant    222
HH                  75
LL                  73
LH                   6
HL                   4
Name: labels, dtype: int64
</pre></div>
</div>
</div>
</div>
<p>This shows, for one, that most local statistics are <em>not</em> statistically significant. Among those that are, we see many more hotspots/coldspots than doughnuts/diamonds-in-the-rough. This is consistent with the skew we saw in the distribution of local statistics earlier.</p>
</div>
<div class="section" id="getis-and-ord-s-local-statistics">
<h2>Getis and Ord’s local statistics<a class="headerlink" href="#getis-and-ord-s-local-statistics" title="Permalink to this headline">¶</a></h2>
<p>Similar to the global case, there are more local indicators of spatial correlation than the local Moran’s I. <code class="docutils literal notranslate"><span class="pre">esda</span></code> includes Getis and Ord’s <span class="math notranslate nohighlight">\(G_i\)</span>-type statistics. These are a different kind of local statistic which are commonly used in two forms: the <span class="math notranslate nohighlight">\(G_i\)</span> statistic, which omits the value at a site in its local summary, and the <span class="math notranslate nohighlight">\(G_i^*\)</span>, which includes the site’s own value in the local summary. The way to calculate them also follows similar patterns as with the Local Moran’s <span class="math notranslate nohighlight">\(I_i\)</span> statistics above. Let us see how that would look like for our Brexit example:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Gi</span>
<span class="n">go_i</span> <span class="o">=</span> <span class="n">esda</span><span class="o">.</span><span class="n">getisord</span><span class="o">.</span><span class="n">G_Local</span><span class="p">(</span><span class="n">db</span><span class="p">[</span><span class="s1">&#39;Pct_Leave&#39;</span><span class="p">],</span> <span class="n">w</span><span class="p">)</span>
<span class="c1"># Gi*</span>
<span class="n">go_i_star</span> <span class="o">=</span> <span class="n">esda</span><span class="o">.</span><span class="n">getisord</span><span class="o">.</span><span class="n">G_Local</span><span class="p">(</span><span class="n">db</span><span class="p">[</span><span class="s1">&#39;Pct_Leave&#39;</span><span class="p">],</span> <span class="n">w</span><span class="p">,</span> <span class="n">star</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>As the local statistics they are, it is best to explore them by plotting them on a map. Unlike with LISA though, the <span class="math notranslate nohighlight">\(G\)</span> statistics only allow to identify positive spatial autocorrelation. When standardized, positive values imply clustering of high values, while negative implies grouping of low values. Unfortunately, it is not possible to discern spatial outliers.</p>
<p>Unlike with LISAs, <code class="docutils literal notranslate"><span class="pre">splot</span></code> does not support vislualisation of G statistics at this point. To visualise their output, we will instead write a little function that generates the map from the statistic’s output object and its set of associated geometries:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">g_map</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">db</span><span class="p">,</span> <span class="n">ax</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Create a cluster map</span>
<span class="sd">    ...</span>
<span class="sd">    </span>
<span class="sd">    Arguments</span>
<span class="sd">    ---------</span>
<span class="sd">    g      : G_Local</span>
<span class="sd">             Object from the computation of the G statistic</span>
<span class="sd">    db     : GeoDataFrame</span>
<span class="sd">             Table aligned with values in `g` and containing </span>
<span class="sd">             the geometries to plot</span>
<span class="sd">    ax     : AxesSubplot</span>
<span class="sd">             `matplotlib` axis to draw the map on</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ax     : AxesSubplot</span>
<span class="sd">             Axis with the map drawn</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">ec</span> <span class="o">=</span> <span class="s1">&#39;0.8&#39;</span>
    
    <span class="c1"># Break observations into significant or not</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">p_sim</span> <span class="o">&lt;</span> <span class="mf">0.05</span>

    <span class="c1"># Plot non-significant clusters</span>
    <span class="n">ns</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sig</span><span class="o">==</span><span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]</span>
    <span class="n">ns</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;lightgrey&#39;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="n">ec</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
    <span class="c1"># Plot HH clusters</span>
    <span class="n">hh</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="n">g</span><span class="o">.</span><span class="n">Zs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">sig</span><span class="o">==</span><span class="kc">True</span><span class="p">),</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]</span>
    <span class="n">hh</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="n">ec</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
    <span class="c1"># Plot LL clusters</span>
    <span class="n">ll</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="n">g</span><span class="o">.</span><span class="n">Zs</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">sig</span><span class="o">==</span><span class="kc">True</span><span class="p">),</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]</span>
    <span class="n">ll</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="n">ec</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
    <span class="c1"># Style and draw</span>
    <span class="n">contextily</span><span class="o">.</span><span class="n">add_basemap</span><span class="p">(</span>
        <span class="n">ax</span><span class="p">,</span> 
        <span class="n">crs</span><span class="o">=</span><span class="n">db</span><span class="o">.</span><span class="n">crs</span><span class="p">,</span> 
        <span class="n">source</span><span class="o">=</span><span class="n">contextily</span><span class="o">.</span><span class="n">providers</span><span class="o">.</span><span class="n">Stamen</span><span class="o">.</span><span class="n">TerrainBackground</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="c1"># Flag to add a star to the title if it&#39;s G_i*</span>
    <span class="n">st</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">star</span><span class="p">:</span>
        <span class="n">st</span> <span class="o">=</span> <span class="s1">&#39;*&#39;</span>
    <span class="c1"># Add title</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;G</span><span class="si">{</span><span class="n">st</span><span class="si">}</span><span class="s1"> statistic for Pct of Leave votes&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
    <span class="c1"># Remove axis for aesthetics</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">ax</span>
</pre></div>
</div>
</div>
</div>
<p>With this function at hand, generating <span class="math notranslate nohighlight">\(G_i^{(*)}\)</span> cluster maps is as straightforward as it is for LISA outputs through <code class="docutils literal notranslate"><span class="pre">splot</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Setup figure and axes</span>
<span class="n">f</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="c1"># Loop over the two statistics</span>
<span class="k">for</span> <span class="n">g</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="n">go_i</span><span class="p">,</span> <span class="n">go_i_star</span><span class="p">],</span> <span class="n">axs</span><span class="o">.</span><span class="n">flatten</span><span class="p">()):</span>
    <span class="c1"># Generate the statistic&#39;s map</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">g_map</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">db</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span>
<span class="c1"># Tight layout to minimise blank spaces</span>
<span class="n">f</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="c1"># Render</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/07_local_autocorrelation_52_0.png" src="../_images/07_local_autocorrelation_52_0.png" />
</div>
</div>
<p>In this case, the results are virtually the same for <span class="math notranslate nohighlight">\(G_i\)</span> and <span class="math notranslate nohighlight">\(G_i^*\)</span>. Also, at first glance, these maps appear to be visually similar to the final LISA map from above. Naturally, this leads to the question: <em>why use the <span class="math notranslate nohighlight">\(G\)</span> statistics at all?</em> The answer to this question is that the two sets of local statistics, local <span class="math notranslate nohighlight">\(I\)</span> and the local <span class="math notranslate nohighlight">\(G\)</span>, are complementary statistics. The local <span class="math notranslate nohighlight">\(I\)</span> statistic (on its own) gives an indication of cluster/outlier status, and the local <span class="math notranslate nohighlight">\(G\)</span> shows which side of the hotspot/coldspot divide the observation is on. Alternatively, the local Moran’s <span class="math notranslate nohighlight">\(I_i\)</span> cluster map provides both pieces of information, but can be more challenging to visualize all at once. Thus, it depends on your analytical preferences and the point of the analysis at hand.</p>
</div>
<div class="section" id="bonus-local-statistics-on-surfaces">
<h2>Bonus: local statistics on surfaces<a class="headerlink" href="#bonus-local-statistics-on-surfaces" title="Permalink to this headline">¶</a></h2>
<p>Before we wrap up the chapter, we are going to cover an illustration that, conceptually, is very similar to the topics we have seen above but, from a technical standpoint, has a bit of a different spin. We will learn how to compute local Moran’s I on data that are stored as a surface, rather than as a geo-table (as we have seen above). As we have seen earlier in the book, more and more data for which we might want to explore local spatial autocorrelation are being provided as surfaces rather than geo-tables. The trick to follow this illustration is to realise that, despite the data structure, surfaces also provide data spatially arranged and that, as such, we can apply the battery of tools we have learned in this chapter to better understand their spatial structure.</p>
<p>Before we start, a note of caution. The functionality required to handle LISA on surfaces is still experimental and a bit rough around the edges. This is because, unlike the case of geo-tables, it has not been a common use-case for geographic data scientists and the tooling eco-system is not as evolved. Nevertheless, it is an exciting time to get started on this, because a lot is happening in this space, and the basic building blocks to develop a full-fledge eco-system are already in place. For this reason, we think it is important to cover in this chapter, even though some of the code we will use below is a bit more sophisticated than what we have seen above. Be patient and do not worry if you have to read things twice (or thrice!) before they start making sense. This is getting into geographic data scientist pro territory!</p>
<p>For this case, we will use the GHSL dataset that contains an extract of gridded population for the metropolitan region of Sao Paulo (Brazil). Let us read the data first into a <code class="docutils literal notranslate"><span class="pre">DataArray</span></code> object:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Open GeoTIFF file and read into `xarray.DataArray`</span>
<span class="n">pop</span> <span class="o">=</span> <span class="n">xarray</span><span class="o">.</span><span class="n">open_rasterio</span><span class="p">(</span>
    <span class="s1">&#39;../data/ghsl/ghsl_sao_paulo.tif&#39;</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Next is building a weights matrix that represents the spatial configuration of pixels with values in <code class="docutils literal notranslate"><span class="pre">pop</span></code>. We will use the same approach as we saw in the chapter on weights:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">w_surface_sp</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">Queen</span><span class="o">.</span><span class="n">from_xarray</span><span class="p">(</span><span class="n">pop</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>So far so good. Now comes the first hairy bit. The weights builder for surfaces automatically generates a matrix with integers (<code class="docutils literal notranslate"><span class="pre">int8</span></code> in this case which, roughly speaking, are numbers without a decimal component):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">w_surface_sp</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">dtype</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>dtype(&#39;int8&#39;)
</pre></div>
</div>
</div>
</div>
<p>For the LISA computation, we will need two changes in <code class="docutils literal notranslate"><span class="pre">w_surface_sp</span></code>. First, the matrix needs to be expressed as floats (roughly speaking, numbers with a decimal component) so we can multiply values and obtain the correct result. Second, we need a <code class="docutils literal notranslate"><span class="pre">W</span></code> object and, so far, we have a <code class="docutils literal notranslate"><span class="pre">WSP</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span><span class="p">(</span><span class="n">w_surface_sp</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>libpysal.weights.weights.WSP
</pre></div>
</div>
</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">WSP</span></code> objects are a thin version of spatial weights matrices that are optimised for certain computations and are more lightweight in terms of memory requirements (they are great, for example, for spatial econometrics). Unfortunately, to calculate LISA statistics we require a few more bits of information, so we have to convert it into a <code class="docutils literal notranslate"><span class="pre">W</span></code> object.</p>
<p>We take both steps in the following code snippet:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">w_surface</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">WSP2W</span><span class="p">(</span>                <span class="c1"># 3.Convert `WSP` object to `W` </span>
    <span class="n">weights</span><span class="o">.</span><span class="n">WSP</span><span class="p">(</span>                          <span class="c1"># 2.Build `WSP` from the float sparse matrix</span>
        <span class="n">w_surface_sp</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="c1"># 1.Convert sparse matrix to floats</span>
    <span class="p">)</span>
<span class="p">)</span>
<span class="n">w_surface</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">w_surface_sp</span><span class="o">.</span><span class="n">index</span>      <span class="c1"># 4.Assign index to new `W`</span>
</pre></div>
</div>
</div>
</div>
<p>There is quite a bit going on in those lines of code, so let’s unpack them:</p>
<ol class="simple">
<li><p>The first step (line 3) is to convert the values from integers into floats. To do this, we access the sparse matrix at the core of <code class="docutils literal notranslate"><span class="pre">w_surface_sp</span></code> (which holds all the main data) and convert it to floats using <code class="docutils literal notranslate"><span class="pre">astype</span></code>.</p></li>
<li><p>Then we convert that sparse matrix into a <code class="docutils literal notranslate"><span class="pre">WSP</span></code> object (line 2), which is a thin wrapper, so the operation is quick.</p></li>
<li><p>Once represented as a <code class="docutils literal notranslate"><span class="pre">WSP</span></code>, we can use Pysal again to convert it into a full-fledge <code class="docutils literal notranslate"><span class="pre">W</span></code> object using the <code class="docutils literal notranslate"><span class="pre">WSP2W</span></code> utility. This step may take a bit more of computing muscle.</p></li>
<li><p>Finally, spatial weights from surfaces include an <code class="docutils literal notranslate"><span class="pre">index</span></code> object that will help us later return data into a surface data structure. Since this is lost with the transformations, we reattach it in the final line (line 6) from the original object.</p></li>
</ol>
<p>This leaves us with a weights object (<code class="docutils literal notranslate"><span class="pre">w_surface</span></code>) we can work with for the LISA. Next is to recast the values from the original data structure to one that <code class="docutils literal notranslate"><span class="pre">Moran_Local</span></code> will understand. This happens in the next code snippet:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Convert `DataArray` to a `pandas.Series`</span>
<span class="n">pop_values</span> <span class="o">=</span> <span class="n">pop</span><span class="o">.</span><span class="n">to_series</span><span class="p">()</span>
<span class="c1"># Subset to keep only values that aren&#39;t missing</span>
<span class="n">pop_values</span> <span class="o">=</span> <span class="n">pop_values</span><span class="p">[</span>
    <span class="n">pop_values</span> <span class="o">!=</span> <span class="n">pop</span><span class="o">.</span><span class="n">rio</span><span class="o">.</span><span class="n">nodata</span>
<span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>Note that we do two operations: one is to convert the two-dimensional <code class="docutils literal notranslate"><span class="pre">DataArray</span></code> surface into a one-dimensional vector in the form of a <code class="docutils literal notranslate"><span class="pre">Series</span></code> object (<code class="docutils literal notranslate"><span class="pre">pop_values</span></code>); the second is to filter out values in which, in the surface, contain missing data. In surfaces, this is usually expressed with a rare value rather than with another data type. We can check that in <code class="docutils literal notranslate"><span class="pre">pop</span></code>, this is -200:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pop</span><span class="o">.</span><span class="n">rio</span><span class="o">.</span><span class="n">nodata</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>-200.0
</pre></div>
</div>
</div>
</div>
<p>At this point, we are ready to run a LISA the same way we have done in previously in the chapter when using geo-tables:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># NOTE: this may take a bit longer to run depending on hardware</span>
<span class="n">pop_lisa</span> <span class="o">=</span> <span class="n">esda</span><span class="o">.</span><span class="n">moran</span><span class="o">.</span><span class="n">Moran_Local</span><span class="p">(</span>
    <span class="n">pop_values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span> <span class="n">w_surface</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Note that, before computing the LISA, we ensure the population values are <em>also</em> expressed as floats and thus in line with those in our spatial weights.</p>
<p>Now we have computed the LISA, on to visualisation. For this, we need to express the results as a surface rather than as a table, for which we will use the bridge built in <code class="docutils literal notranslate"><span class="pre">pysal</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">libpysal.weights</span> <span class="kn">import</span> <span class="n">raster</span>
</pre></div>
</div>
</div>
</div>
<p>We are aiming to create a cluster plot. This means we want to display values that are statistically significant in a color aligned with the quadrant of the Moran plot in which they lie. For this, we will create a new <code class="docutils literal notranslate"><span class="pre">Series</span></code> that intersects the quadrant information with significance. We use a 1% level for the example:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sig_pop</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
    <span class="n">pop_lisa</span><span class="o">.</span><span class="n">q</span> <span class="o">*</span> <span class="p">(</span><span class="n">pop_lisa</span><span class="o">.</span><span class="n">p_sim</span> <span class="o">&lt;</span> <span class="mf">.01</span><span class="p">),</span> <span class="c1"># Quadrant of significant at 1% (0 otherwise)</span>
    <span class="n">index</span><span class="o">=</span><span class="n">pop_values</span><span class="o">.</span><span class="n">index</span>               <span class="c1"># Index from the Series and aligned with `w_surface`</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">sig_pop</span></code> object, expressed as a one-dimensional vector, contains the information we would like to recast into a <code class="docutils literal notranslate"><span class="pre">DataArray</span></code> object. For this conversion, we can use the <code class="docutils literal notranslate"><span class="pre">w2da</span></code> function, which derives the spatial configuration of each value in <code class="docutils literal notranslate"><span class="pre">sig_pop</span></code> from <code class="docutils literal notranslate"><span class="pre">w_surface</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Build `DataArray` from a set of values and weights</span>
<span class="n">lisa_da</span> <span class="o">=</span> <span class="n">raster</span><span class="o">.</span><span class="n">w2da</span><span class="p">(</span>
    <span class="n">sig_pop</span><span class="p">,</span>                                      <span class="c1"># Values</span>
    <span class="n">w_surface</span><span class="p">,</span>                                    <span class="c1"># Spatial weights</span>
    <span class="n">attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;nodatavals&#39;</span><span class="p">:</span> <span class="n">pop</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;nodatavals&#39;</span><span class="p">]}</span> <span class="c1"># Value for missing data</span>
<span class="c1"># Add CRS information in a compliant manner</span>
<span class="p">)</span><span class="o">.</span><span class="n">rio</span><span class="o">.</span><span class="n">write_crs</span><span class="p">(</span><span class="n">pop</span><span class="o">.</span><span class="n">rio</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The resulting <code class="docutils literal notranslate"><span class="pre">DataArray</span></code> only contains missing data pixels (expressed with the same value as the original <code class="docutils literal notranslate"><span class="pre">pop</span></code>, -200), <code class="docutils literal notranslate"><span class="pre">0</span></code> for non-significant pixels, and 1-4 depending on the quadrant for HH, LH, LL, HL significant clusters, same as with the Brexit example before:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">lisa_da</span><span class="o">.</span><span class="n">to_series</span><span class="p">()</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([-200,    0,    3,    1,    2,    4])
</pre></div>
</div>
</div>
</div>
<p>We have all the data in the right shape to build the figure. Before we can do that, we need to hardwire the coloring scheme on our own. This is something that we do not have to pay attention to when working with geo-tables thanks to <code class="docutils literal notranslate"><span class="pre">splot</span></code>. For surfaces, we are not that lucky.</p>
<p>First, we create the colormap to encode clusters with the same colors that <code class="docutils literal notranslate"><span class="pre">splot</span></code> uses for geo-tables. For that, we need the method in <code class="docutils literal notranslate"><span class="pre">matplotlib</span></code> that builds a color map from a list of colors:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">matplotlib.colors</span> <span class="kn">import</span> <span class="n">ListedColormap</span>
</pre></div>
</div>
</div>
</div>
<p>We express the colors we will use as a dictionary mapping the key to the color code:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># LISA colors</span>
<span class="n">lc</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;ns&#39;</span><span class="p">:</span> <span class="s1">&#39;lightgrey&#39;</span><span class="p">,</span> <span class="c1"># Values of 0</span>
    <span class="s1">&#39;HH&#39;</span><span class="p">:</span> <span class="s1">&#39;#d7191c&#39;</span><span class="p">,</span>   <span class="c1"># Values of 1</span>
    <span class="s1">&#39;LH&#39;</span><span class="p">:</span> <span class="s1">&#39;#abd9e9&#39;</span><span class="p">,</span>   <span class="c1"># Values of 2</span>
    <span class="s1">&#39;LL&#39;</span><span class="p">:</span> <span class="s1">&#39;#2c7bb6&#39;</span><span class="p">,</span>   <span class="c1"># Values of 3</span>
    <span class="s1">&#39;HL&#39;</span><span class="p">:</span> <span class="s1">&#39;#fdae61&#39;</span><span class="p">,</span>   <span class="c1"># Values of 4</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<p>With these pieces, we can create the colormap object:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">lisa_cmap</span> <span class="o">=</span> <span class="n">ListedColormap</span><span class="p">(</span>
    <span class="p">[</span><span class="n">lc</span><span class="p">[</span><span class="s1">&#39;ns&#39;</span><span class="p">],</span> <span class="n">lc</span><span class="p">[</span><span class="s1">&#39;HH&#39;</span><span class="p">],</span> <span class="n">lc</span><span class="p">[</span><span class="s1">&#39;LH&#39;</span><span class="p">],</span> <span class="n">lc</span><span class="p">[</span><span class="s1">&#39;LL&#39;</span><span class="p">],</span> <span class="n">lc</span><span class="p">[</span><span class="s1">&#39;HL&#39;</span><span class="p">]]</span>
<span class="p">)</span>
<span class="n">lisa_cmap</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div style="vertical-align: middle;"><strong>from_list</strong> </div><div class="cmap"><img alt="from_list colormap" title="from_list" style="border: 1px solid #555;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAABACAYAAABsv8+/AAAAGHRFWHRUaXRsZQBmcm9tX2xpc3QgY29sb3JtYXBDL89FAAAAHnRFWHREZXNjcmlwdGlvbgBmcm9tX2xpc3QgY29sb3JtYXABtCnOAAAAMHRFWHRBdXRob3IATWF0cGxvdGxpYiB2My40LjMsIGh0dHBzOi8vbWF0cGxvdGxpYi5vcmcJXfPTAAAAMnRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHYzLjQuMywgaHR0cHM6Ly9tYXRwbG90bGliLm9yZyf7bPQAAAFOSURBVHic7dZBDQJBAARBIDjCAwmysML3TGCAB1n8gIG7L3tJVymYZD59HGN8D+zS+XqbPYEVn+dr9gRW3B9+2aP3ZZk9gQ2n2QMAgP8TAAAQJAAAIEgAAECQAACAIAEAAEECAACCBAAABAkAAAgSAAAQJAAAIEgAAECQAACAIAEAAEECAACCBAAABAkAAAgSAAAQJAAAIEgAAECQAACAIAEAAEECAACCBAAABAkAAAgSAAAQJAAAIEgAAECQAACAIAEAAEECAACCBAAABAkAAAgSAAAQJAAAIEgAAECQAACAIAEAAEECAACCBAAABAkAAAgSAAAQJAAAIEgAAECQAACAIAEAAEECAACCBAAABAkAAAgSAAAQJAAAIEgAAECQAACAIAEAAEECAACCBAAABAkAAAgSAAAQJAAAIEgAAECQAACAIAEAAEECAACCfhcVCotxILZcAAAAAElFTkSuQmCC"></div><div style="vertical-align: middle; max-width: 514px; display: flex; justify-content: space-between;"><div style="float: left;"><div title="#d3d3d3ff" style="display: inline-block; width: 1em; height: 1em; margin: 0; vertical-align: middle; border: 1px solid #555; background-color: #d3d3d3ff;"></div> under</div><div style="margin: 0 auto; display: inline-block;">bad <div title="#00000000" style="display: inline-block; width: 1em; height: 1em; margin: 0; vertical-align: middle; border: 1px solid #555; background-color: #00000000;"></div></div><div style="float: right;">over <div title="#fdae61ff" style="display: inline-block; width: 1em; height: 1em; margin: 0; vertical-align: middle; border: 1px solid #555; background-color: #fdae61ff;"></div></div></div></div>
</div>
<p>At this point, we have all the pieces we need to build our cluster map. Let’s put them together:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set up figure and axis</span>
<span class="n">f</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
                    <span class="c1"># Subplot 1 #       </span>
<span class="c1"># Select pixels that do not have the `nodata` value</span>
<span class="c1"># (ie. they are not missing data)</span>
<span class="n">pop</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
    <span class="n">pop</span><span class="o">!=</span><span class="n">pop</span><span class="o">.</span><span class="n">rio</span><span class="o">.</span><span class="n">nodata</span>
<span class="c1"># Plot surface with a horizontal colorbar</span>
<span class="p">)</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
    <span class="n">ax</span><span class="o">=</span><span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">add_colorbar</span><span class="o">=</span><span class="kc">False</span><span class="c1">#, cbar_kwargs={&quot;orientation&quot;: &quot;horizontal&quot;}</span>
<span class="p">)</span>
                    <span class="c1"># Subplot 2 #</span>
<span class="c1"># Select pixels with no missing data and rescale to [0, 1] by</span>
<span class="c1"># dividing by 4 (maximum value in `lisa_da`) </span>
<span class="p">(</span>
    <span class="n">lisa_da</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">lisa_da</span><span class="o">!=-</span><span class="mi">200</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span>
<span class="c1"># Plot surface without a colorbar</span>
<span class="p">)</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cmap</span><span class="o">=</span><span class="n">lisa_cmap</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">add_colorbar</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="c1"># Aesthetics #</span>
<span class="c1"># Subplot titles</span>
<span class="n">titles</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Population by pixel&#39;</span><span class="p">,</span> <span class="s1">&#39;Population clusters&#39;</span><span class="p">]</span>
<span class="c1"># Apply the following to each of the two subplots</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
    <span class="c1"># Keep proportion of axes</span>
    <span class="n">axs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
    <span class="c1"># Remove axis</span>
    <span class="n">axs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
    <span class="c1"># Add title</span>
    <span class="n">axs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">titles</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="c1"># Add basemap</span>
    <span class="n">contextily</span><span class="o">.</span><span class="n">add_basemap</span><span class="p">(</span><span class="n">axs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">crs</span><span class="o">=</span><span class="n">lisa_da</span><span class="o">.</span><span class="n">rio</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/07_local_autocorrelation_86_0.png" src="../_images/07_local_autocorrelation_86_0.png" />
</div>
</div>
</div>
<div class="section" id="conclusion">
<h2>Conclusion<a class="headerlink" href="#conclusion" title="Permalink to this headline">¶</a></h2>
<p>Local statistics are one of the most commonly-used tools in the geographic data science toolkit. When used properly, local statistics provide a powerful way to analyze and visualize the structure of geographic data. The Local Moran’s <span class="math notranslate nohighlight">\(I_i\)</span> statistic, as Local Indicator of Spatial Association, summarizes the co-variation between observations and their immediate surroundings. The Getis-Ord local <span class="math notranslate nohighlight">\(G\)</span> statistics, on the other hand, compare the sum of values in the area around each site. Regardless, learning to use local statistics effectively is important for any geographic data scientist, as they are the most common “first brush” geographic statistic for many analyses.</p>
</div>
<div class="section" id="questions">
<h2>Questions<a class="headerlink" href="#questions" title="Permalink to this headline">¶</a></h2>
<ol class="simple">
<li><p>Do the same Local Moran analysis done for <code class="docutils literal notranslate"><span class="pre">Pct_Leave</span></code>, but using <code class="docutils literal notranslate"><span class="pre">Pct_Turnout</span></code>. Is there a geography to how involved people were in different places? Where was turnout percentage (relatively) higher or lower?</p></li>
<li><p>Do the same Getis-Ord analysis done for <code class="docutils literal notranslate"><span class="pre">Pct_Leave</span></code>, but using <code class="docutils literal notranslate"><span class="pre">Pct_Turnout</span></code>.</p></li>
<li><p>Local Moran statistics are premised on a few distributional assumptions. One well-recognized concern with Moran statistics is when they are estimated for <em>rates</em>. Rate data is distinct from other kinds of data because it embeds the relationship between two quantities: the event and the population. For instance, in the case of Leave voting, the “event” is a person voting leave, and the “population” could be the number of eligible voters, the number of votes cast, or the total number of people. This usually only poses a problem for analysis when the event outcome is somehow dependent on the population.</p>
<ul class="simple">
<li><p>Using our past analytical steps, build a new <code class="docutils literal notranslate"><span class="pre">db</span></code> dataframe from <code class="docutils literal notranslate"><span class="pre">ref</span></code> and <code class="docutils literal notranslate"><span class="pre">lads</span></code> that contains the <code class="docutils literal notranslate"><span class="pre">Electorate</span></code>, <code class="docutils literal notranslate"><span class="pre">Votes_Cast</span></code>, and <code class="docutils literal notranslate"><span class="pre">Leave</span></code> columns.</p></li>
<li><p>From this new dataframe, make scatterplots of:</p>
<ul>
<li><p>the number of votes cast and the percent leave vote</p></li>
<li><p>the size of the electorate and the percent of leave vote</p></li>
</ul>
</li>
<li><p>Based on your answers to the previous point, does it appear that there is a relationship between the event and the population size? Use <code class="docutils literal notranslate"><span class="pre">scipy.stats.kendalltau</span></code> or <code class="docutils literal notranslate"><span class="pre">scipy.stats.pearsonr</span></code>  to confirm your visual intuition.</p></li>
<li><p>Using <code class="docutils literal notranslate"><span class="pre">esda.moran.Moran_Rate</span></code>, estimate a global Moran’s I that takes into account the rate structure of <code class="docutils literal notranslate"><span class="pre">Pct_Leave</span></code>, using the <code class="docutils literal notranslate"><span class="pre">Electorate</span></code> as the population. Is this estimate different from the one obtained without taking into account the rate structure? What about when <code class="docutils literal notranslate"><span class="pre">Votes_Cast</span></code> is used for the population?</p></li>
<li><p>Using <code class="docutils literal notranslate"><span class="pre">esda.moran.Moran_Local_Rate</span></code>, estimate <em>local</em> Moran’s I treating Leave data as a rate.</p>
<ul>
<li><p>does any site’s local I change? Make a scatterplot of the <code class="docutils literal notranslate"><span class="pre">lisa.Is</span></code> you estimated before and this new rate-based local Moran.</p></li>
<li><p>does any site’s local I change their outlier/statistical significance classifications? Use <code class="docutils literal notranslate"><span class="pre">pandas.crosstab</span></code> to examine how many classifications change between the two kinds of statistic. Make sure to consider observations’ statistical significances in addition to their quadrant classification.</p></li>
</ul>
</li>
<li><p>Make two maps, side by side, of the local statistics without rate correction and with rate correction. Does your interpretation of the maps change depending on the correction?</p></li>
</ul>
</li>
<li><p>Local statistics use <em>permutation-based</em> inference for their significance testing. This means that, to test the statistical significance of a local relationship, values of the observed variable are <em>shuffled</em> around the map. These large numbers of <em>random</em> maps are then used to compare against the observed map. Local inference requires some restrictions on how each shuffle occurs, since each observation must be “fixed” and compared to randomly-shuffle neighboring observations. The distribution of local statistics for each “shuffle” is contained in the <code class="docutils literal notranslate"><span class="pre">.rlisas</span></code> attribute of a Local Moran object.</p>
<ul class="simple">
<li><p>For the first observation, make a <code class="docutils literal notranslate"><span class="pre">seaborn.distplot</span></code> of its shuffled local statistics. Add a vertical line to the histogram using <code class="docutils literal notranslate"><span class="pre">plt.axvline()</span></code>.</p></li>
<li><p>Do the same for the last observation as well.</p></li>
<li><p>Looking only at their permutation distributions, do you expect the first LISA statistic to be statistically-significant? Do you expect the last?</p></li>
</ul>
</li>
<li><p>LISAs have some amount of fundamental uncertainty due to their estimation. This is called the <code class="docutils literal notranslate"><span class="pre">standard</span> <span class="pre">error</span></code> of the statistic.</p>
<ul class="simple">
<li><p>The standard errors are contained in the <code class="docutils literal notranslate"><span class="pre">.seI_sim</span></code> attribute. Make a map of the standard errors. Are there any areas of the map that appear to be more uncertain about their local statistics?</p></li>
<li><p>compute the standard deviation of each observation’s “shuffle” distribution, contained in the <code class="docutils literal notranslate"><span class="pre">.rlisas</span></code> attribute. Verify that the standard deviation of this shuffle distribution is the same as the standard errors in <code class="docutils literal notranslate"><span class="pre">seI_sim</span></code>.</p></li>
</ul>
</li>
<li><p>Local Getis-Ord statistics come in two forms. As discussed above, Getis-Ord <span class="math notranslate nohighlight">\(G_i\)</span> statistics <em>omit</em> each site from their own local statistic. In contrast, <span class="math notranslate nohighlight">\(G_i^*\)</span> statistics <em>include</em> the site in its own local statistic.</p>
<ul class="simple">
<li><p>Make a scatterplot of the two types of statistic, contained in <code class="docutils literal notranslate"><span class="pre">gostats.Zs</span></code> and <code class="docutils literal notranslate"><span class="pre">gostars.Zs</span></code> to examine how similar the two forms of the Getis-Ord statistic are.</p></li>
<li><p>The two forms of the Getis-Ord statistic differ by their inclusion of the <em>site</em> value, <span class="math notranslate nohighlight">\(y_i\)</span>, in the value for the <span class="math notranslate nohighlight">\(G_i\)</span> statistic at that site. So, make a scatterplot of the percent leave variable and the <em>difference</em> of the two statistics. Is there a relationship between the percent leave vote and the difference in the two forms of the Getis-Ord statistic? Confirm this for yourself using <code class="docutils literal notranslate"><span class="pre">scipy.stats.kendalltau</span></code> or <code class="docutils literal notranslate"><span class="pre">scipy.stats.pearsonr</span></code>.</p></li>
</ul>
</li>
</ol>
</div>
<div class="section" id="next-steps">
<h2>Next Steps<a class="headerlink" href="#next-steps" title="Permalink to this headline">¶</a></h2>
<p>For more thinking on the foundational methods and concepts in local testing, Fotheringham is a classic:</p>
<p>Fotheringham, A. Stewart. 1997. “Trends in Quantitative Methods I: Stressing the local.” <em>Progress in Human Geography</em> 21(1): 88-96.</p>
<p>More recent discussion on local statistics (in the context of spatial statistics more generally) is provided by Nelson:</p>
<p>Nelson, Trisalyn. “Trends in Spatial Statistics.” <em>The Professional Geographer</em> 64(1): 83-94.</p>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./notebooks"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            
                <!-- Previous / next buttons -->
<div class='prev-next-area'> 
    <a class='left-prev' id="prev-link" href="06_spatial_autocorrelation.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Global Spatial Autocorrelation</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="08_point_pattern_analysis.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Point Pattern Analysis</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            
        </div>
    </div>
    <footer class="footer">
  <p>
    
      By Sergio J. Rey, Dani Arribas-Bel, Levi J. Wolf<br/>
    
        &copy; Copyright 2020.<br/>
      <div class="extra_footer">
        <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.

      </div>
  </p>
</footer>
</main>


      </div>
    </div>
  
  <script src="../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>

  </body>
</html>