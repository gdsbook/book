

<!DOCTYPE html>


<html >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Spatial Feature Engineering &#8212; Geographic Data Science with Python</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js"></script>
    <script async="async" src="https://www.googletagmanager.com/gtag/js?id=UA-146598819-1"></script>
    <script>
                window.dataLayer = window.dataLayer || [];
                function gtag(){ dataLayer.push(arguments); }
                gtag('js', new Date());
                gtag('config', 'UA-146598819-1');
            </script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'notebooks/12_feature_engineering';</script>
    <link rel="canonical" href="https://geographicdata.science/book/notebooks/12_feature_engineering.html" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="References" href="references.html" />
    <link rel="prev" title="Spatial Regression" href="11_regression.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="None"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="../intro.html">
  
  
  
  
    
    
      
    
    
    <img src="../_static/logo.png" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="../_static/logo.png" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro.html">
                    Home
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Preface</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="00_toc.html">Table of Contents</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Part I - Building Blocks</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../intro_part_i.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="01_geo_thinking.html">Geographic Thinking for Data Scientists</a></li>
<li class="toctree-l1"><a class="reference internal" href="02_geospatial_computational_environment.html">Computational Tools for Geographic Data Science</a></li>
<li class="toctree-l1"><a class="reference internal" href="03_spatial_data.html">Spatial Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="04_spatial_weights.html">Spatial Weights</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Part II - Spatial Data Analysis</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../intro_part_ii.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="05_choropleth.html">Choropleth Mapping</a></li>
<li class="toctree-l1"><a class="reference internal" href="06_spatial_autocorrelation.html">Global Spatial Autocorrelation</a></li>
<li class="toctree-l1"><a class="reference internal" href="07_local_autocorrelation.html">Local Spatial Autocorrelation</a></li>
<li class="toctree-l1"><a class="reference internal" href="08_point_pattern_analysis.html">Point Pattern Analysis</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Part III - Advanced Topics</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../intro_part_iii.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="09_spatial_inequality.html">Spatial Inequality Dynamics</a></li>
<li class="toctree-l1"><a class="reference internal" href="10_clustering_and_regionalization.html">Clustering and Regionalization</a></li>
<li class="toctree-l1"><a class="reference internal" href="11_regression.html">Spatial Regression</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Spatial Feature Engineering</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Endmatter</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="references.html">References</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Datasets</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../data/README.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../data/airbnb/regression_cleaning.html">AirBnb</a></li>
<li class="toctree-l1"><a class="reference internal" href="../data/airports/airports_cleaning.html">Airports</a></li>
<li class="toctree-l1"><a class="reference internal" href="../data/brexit/brexit_cleaning.html">Brexit</a></li>
<li class="toctree-l1"><a class="reference internal" href="../data/countries/countries_cleaning.html">Countries</a></li>
<li class="toctree-l1"><a class="reference internal" href="../data/ghsl/build_ghsl_extract.html">GHSL</a></li>
<li class="toctree-l1"><a class="reference internal" href="../data/h3_grid/build_sd_h3_grid.html">H3 Grid</a></li>
<li class="toctree-l1"><a class="reference internal" href="../data/mexico/README.html">Mexico</a></li>
<li class="toctree-l1"><a class="reference internal" href="../data/nasadem/build_nasadem_sd.html">NASA DEM</a></li>
<li class="toctree-l1"><a class="reference internal" href="../data/sandiego/sandiego_tracts_cleaning.html">San Diego Tracts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../data/texas/README.html">Texas</a></li>
<li class="toctree-l1"><a class="reference internal" href="../data/tokyo/tokyo_cleaning.html">Tokyo Photographs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../data/us_county_income/README.html">US County Income 1969-2017</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-launch-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Launch interactive content">
    <i class="fas fa-rocket"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://mybinder.org/v2/gh/gdsbook/book/master?urlpath=lab/tree/notebooks/12_feature_engineering.ipynb" target="_blank"
   class="btn btn-sm dropdown-item"
   title="Launch onBinder"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  
    <img src="../_static/images/logo_binder.svg">
  </span>
<span class="btn__text-container">Binder</span>
</a>
</li>
      
      
      
      
      <li><a href="https://colab.research.google.com/github/gdsbook/book/blob/master/notebooks/12_feature_engineering.ipynb" target="_blank"
   class="btn btn-sm dropdown-item"
   title="Launch onColab"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  
    <img src="../_static/images/logo_colab.png">
  </span>
<span class="btn__text-container">Colab</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/notebooks/12_feature_engineering.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Spatial Feature Engineering</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#what-is-spatial-feature-engineering">What is spatial feature engineering?</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#feature-engineering-using-map-matching">Feature engineering using map matching</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#counting-nearby-features">Counting <em>nearby</em> features</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#assigning-point-values-from-surfaces-elevation-of-airbnbs">Assigning point values from surfaces: elevation of Airbnbs</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#point-interpolation-using-scikit-learn">Point interpolation using scikit-learn</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#polygon-to-point">Polygon to point</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#area-to-area-interpolation">Area to area interpolation</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#feature-engineering-using-map-synthesis">Feature engineering using map synthesis</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#spatial-summary-features-in-map-synthesis">Spatial summary features in map synthesis</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#counting-neighbors">Counting neighbors</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#distance-buffers-within-a-single-table">Distance buffers within a single table</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#ring-buffer-features">“Ring” buffer features</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#clustering-as-feature-engineering">Clustering as feature engineering</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#conclusion">Conclusion</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#questions">Questions</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#next-steps">Next steps</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="spatial-feature-engineering">
<h1>Spatial Feature Engineering<a class="headerlink" href="#spatial-feature-engineering" title="Permalink to this headline">#</a></h1>
<p>In machine learning and data science, we are often equipped with <em>tons</em> of data. Indeed, given the constellation of packages to query data services, free and open source data-sets, and the rapid and persistent collection of geographical data, there is simply too much data to even represent coherently in a single, tidy fashion. However, we often need to be able to construct useful <em>features</em> from this rich and deep sea of data.</p>
<p>Where data is available, but not yet directly <em>usable</em>, <em>feature engineering</em> helps to construct representations or transformations of the original data that are more useful for modeling a given phenomenon of interest. In traditional machine learning, feature engineering involves applying additional <em>domain knowledge</em> to raw information in order to structure it in a manner that is meaningful for a model. Often, this involves some sort of <em>transformation</em> of the original dataset, which is a well-studied concept in both classical statistics and remains so in machine learning methods. While <em>feature engineering</em> always relies on this implicit domain knowledge, it is an extremely important part of adapting general-purpose algorithms to unique or distinctive problems facing the every-day data scientist.</p>
<p>Geography is one of the most high-quality, ubiquitous ways to introduce <em>domain knowledge</em> into a problem: everything has a position in both <em>space</em> and <em>time</em>. And, while things that happen near one another <em>in time</em> do not necessarily have a fundamental relationship, things that are <em>near</em> one another are often related. Thus, space is the ultimate <em>linkage key</em>, allowing us to connect different datasets together in order to improve our models and our predictions. This means that, even for <em>aspatial</em>, “non-geographic” data, you can use <em>spatial feature engineering</em> to create useful, highly relevant features for your analysis.</p>
<p>At its core, <em>spatial feature engineering</em> is the process of developing additional information from raw data using <em>geographic knowledge</em>. This distilling of information can occur <em>between</em> datasets, where geography is used to link information in separate datasets together; or <em>within</em> datasets, where geography can be used to augment the information available for one sample by borrowing from nearby ones. This chapter is structured following that distinction: for cases where geography connects <em>different</em> datasets, we adopt the term “Map Matching”, often used in industry; while we use the mirroring concept of “Map Synthesis” describing the use of geographical structure to derive new features from a given dataset. Technically speaking, some of the methods we review are similar across these two cases, or even the same; however, they can be applied in the context of “matching” or “synthesis”, and we consider those conceptually different, hence their inclusion in both sections. Throughout the chapter, we use the Airbnb nightly rental prices in San Diego, as well as auxiliary datasets such as elevation or census demographics.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">geopandas</span><span class="o">,</span> <span class="nn">pandas</span><span class="o">,</span> <span class="nn">libpysal.weights</span> <span class="k">as</span> <span class="nn">weights</span><span class="o">,</span> <span class="nn">contextily</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">cenpy</span>
<span class="kn">import</span> <span class="nn">osmnx</span>
<span class="kn">import</span> <span class="nn">seaborn</span>
<span class="kn">import</span> <span class="nn">rasterio</span>
<span class="kn">from</span> <span class="nn">rasterio.plot</span> <span class="kn">import</span> <span class="n">show</span> <span class="k">as</span> <span class="n">rioshow</span>
</pre></div>
</div>
</div>
</div>
<p>Throughout this chapter, we will use the same dataset to which we want to append more information or augment, and we will do so through leveraging geography. For the illustration, we will use the set of <a class="reference internal" href="../data/airbnb/regression_cleaning.html"><span class="doc std std-doc">Airbnb properties</span></a> we have used in <a class="reference internal" href="11_regression.html"><span class="doc std std-doc">Chapter 11</span></a>. Let’s read it:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">airbnbs</span> <span class="o">=</span> <span class="n">geopandas</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s2">&quot;../data/airbnb/regression_db.geojson&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<section id="what-is-spatial-feature-engineering">
<h2>What is spatial feature engineering?<a class="headerlink" href="#what-is-spatial-feature-engineering" title="Permalink to this headline">#</a></h2>
<p>At its core, <em>spatial feature engineering</em> is the process of developing additional information from raw data using <em>geographic knowledge</em>. This synthesis could occur <em>between</em> datasets, where geography is used to link samples in separate datasets together; or <em>within</em> datasets, where geography can be used to borrow information from nearby samples. Building linkages <em>between</em> datasets is often called “Map Matching”, while we use the term “Map Synthesis” to describe the use of geographical structure to derive new features from existing data. We will cover both kinds of feature engineering.</p>
<p>To help us discuss this, a vocabulary is helpful. We will cover a few different kinds of features in this chapter. All of them can be constructed using either Map Synthesis or Map Matching operations:</p>
<ul class="simple">
<li><p>A <em>spatial summary feature</em> measures the attributes of observations that have some pre-specified spatial relationship with our target observations. This includes:</p>
<ul>
<li><p>Taking the average or median value of features within a neighborhood of each target observation.</p></li>
<li><p>The <em>spatial lag</em>, used in previous chapters of this book, e.g., Chapters <a class="reference internal" href="03_spatial_data.html"><span class="doc std std-doc">3</span></a>, <a class="reference internal" href="06_spatial_autocorrelation.html"><span class="doc std std-doc">6</span></a>, and <a class="reference internal" href="11_regression.html"><span class="doc std std-doc">11</span></a>, is a kind of spatial summary feature, since it reflects the average value of the data in the neighborhood around each point.</p></li>
<li><p>Other kinds of spatial summary features might include the count of observations within a given distance or the standard deviation of ten nearest observations.</p></li>
<li><p>Summary features generally include <em>interpolated features</em> which involve a transfer of information from one spatial support to another, such as when the target locations are not the same as the locations in our ancillary data. Interpolated features become significantly more complex as well when the data is <em>areal</em>, as will be discussed later in this chapter.</p></li>
</ul>
</li>
<li><p>A <em>proximity feature</em> measures the distance from a target observation to some other observation or position in the map. This might be done in a map matching context, as we did before with the distance to Balboa Park in <a class="reference internal" href="11_regression.html"><span class="doc std std-doc">Chapter 11</span></a>, or it might be done in a map synthesis context by measuring the distance to the nearest other observation.</p></li>
</ul>
</section>
<section id="feature-engineering-using-map-matching">
<h2>Feature engineering using map matching<a class="headerlink" href="#feature-engineering-using-map-matching" title="Permalink to this headline">#</a></h2>
<p>Space is the ultimate linkage key; map matching is all about exploiting this asset. Geographic information is collected at different scales, aggregated using bespoke geographic delineations, and ultimately stored in different datasets. Modeling and machine learning usually require the use of data aligned and coherently structured; to bring disparate geo-datasets together, the data scientist needs to be able to transfer information expressed for one geography into another. This is where map matching comes to the rescue. By using geographical location, we can connect datasets that have no common key or that are otherwise completely unrelated. This is a “magic trick” that we can pull off because of location that would be much harder, or impossible, with data lacking spatial information.</p>
<p>The details, and difficulty, of this transfer of information from one geography to another one depend on the nature of the “source” and “target”, and on the precision with which we want to perform such transfer. In this context, there is always an inevitable trade-off between precision and sophistication: more precise transfer is usually possible at the expense of more advanced and involved techniques. Their additional cost in applying them, both in terms of cognitive load on the data scientist’s part or in terms of computation, must be weighted in on an individual basis: sometimes we need the best possible estimates, at all costs; sometimes “good enough” is, well, good enough.</p>
<p>In this section, we cover a few cases that we consider represent the most common and widely used approaches. We begin with situations where we have two point datasets and all we need to calculate are descriptive statistics of one dataset to the observations in the other. We switch the type of data and consider how to attach information from a continuous grid, stored in a raster file, to a set of points. Then we show the equivalent case for “moving” information for a polygon geography to a point dataset. These are all cases that, in their simplest form, involve mostly traditional GIS operations (e.g., buffer construction, spatial joins) and little in the way of statistical modeling. As an example of a case that is more involved, we cover the transfer of information from a set of points to another set of points in different locations, and of a polygon geography to another different polygon geography. For these final cases, but also more generally, we try to include examples that capture the essence of the method but keep the technique as simple as possible. For almost any of these cases we cover, the reader can find more sophisticated techniques that usually yield more accurate estimates. Where possible, we try to signpost these.</p>
<section id="counting-nearby-features">
<h3>Counting <em>nearby</em> features<a class="headerlink" href="#counting-nearby-features" title="Permalink to this headline">#</a></h3>
<p>A first, conceptually straightforward, approach is to augment our dataset by counting how many points of a different dataset are in the vicinity of each observation. For example, we might want to know how many bars and restaurants each Airbnb has within a given radius. This count can then become an additional  feature of our dataset, stored in a new column of <code class="docutils literal notranslate"><span class="pre">airbnbs</span></code>.</p>
<p>To obtain information on the location of restaurants and bars, we can download it from OpenStreetMap directly using <code class="docutils literal notranslate"><span class="pre">osmnx</span></code>. We first query all the points of interest (POIs) within the area our points cover, and then filter out everything except restaurants and bars. For that, we require  a polygon that covers all our <code class="docutils literal notranslate"><span class="pre">airbnbs</span></code> points. From <a class="reference internal" href="08_point_pattern_analysis.html"><span class="doc std std-doc">Chapter 8</span></a>, we can recall that there are a few different hulls that can be used. We’ll use the Convex Hull here (Fig. XXX1XXX), which is the smallest convex polygon that covers all the points in the set.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">airbnbs_ch</span> <span class="o">=</span> <span class="n">airbnbs</span><span class="o">.</span><span class="n">unary_union</span><span class="o">.</span><span class="n">convex_hull</span>
<span class="n">geopandas</span><span class="o">.</span><span class="n">GeoSeries</span><span class="p">([</span><span class="n">airbnbs_ch</span><span class="p">])</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;Axes: &gt;
</pre></div>
</div>
<img alt="../_images/0a952b360dacefa002788242cefb7a07e21ed2d57959ac5af485a368998117b9.png" src="../_images/0a952b360dacefa002788242cefb7a07e21ed2d57959ac5af485a368998117b9.png" />
</div>
</div>
<p>Using this polygon, we can use the <code class="docutils literal notranslate"><span class="pre">osmnx</span></code> package to fetch POIs from OpenStreetMap. We can make our request more manageable by only requesting POIs that fall within specific categories. Below, we’ll request POIs within San Diego that are “restaurants” or “bars,” according to their metadata stored in OpenStreetMap. Once returned, we only use a few columns to keep the table small and tidy:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%%time</span>
<span class="n">pois</span> <span class="o">=</span> <span class="n">osmnx</span><span class="o">.</span><span class="n">geometries_from_polygon</span><span class="p">(</span>
    <span class="n">airbnbs_ch</span><span class="p">,</span> <span class="n">tags</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;amenity&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;restaurant&quot;</span><span class="p">,</span> <span class="s2">&quot;bar&quot;</span><span class="p">]}</span>
<span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()[</span>
    <span class="p">[</span>
        <span class="s2">&quot;element_type&quot;</span><span class="p">,</span>
        <span class="s2">&quot;osmid&quot;</span><span class="p">,</span>
        <span class="s2">&quot;amenity&quot;</span><span class="p">,</span>
        <span class="s2">&quot;cuisine&quot;</span><span class="p">,</span>
        <span class="s2">&quot;name&quot;</span><span class="p">,</span>
        <span class="s2">&quot;geometry&quot;</span><span class="p">,</span>
    <span class="p">]</span>
<span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>CPU times: user 247 ms, sys: 425 µs, total: 248 ms
Wall time: 244 ms
</pre></div>
</div>
</div>
</div>
<p>The code snippet above sends a query to the OpenStreetMap server to fetch the data on amenities. Note that it <em>requires</em> internet connectivity to work. If you are working on the book <em>without</em> connectivity, a cached version of the dataset is available on the data folder and can be read as:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pois</span> <span class="o">=</span> <span class="n">geopandas</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s2">&quot;../data/cache/sd_pois.gpkg&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>This provides us with every location within our convex hull that is tagged in the metadata stored in OpenStreetMap as a “restaurant” or “bar”. Overall, this provides us with about 1300 POIs:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pois</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;amenity&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">amenity</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>amenity
bar            308
restaurant    1060
Name: amenity, dtype: int64
</pre></div>
</div>
</div>
</div>
<p>Once loaded into <code class="docutils literal notranslate"><span class="pre">pois</span></code> as a <code class="docutils literal notranslate"><span class="pre">GeoDataFrame</span></code>, we use the code below to generate Figure XXX2XXX, which takes a peek at their location, as compared with Airbnb spots:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set up figure and axis</span>
<span class="n">f</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>
<span class="c1"># Plot Airbnb properties</span>
<span class="n">airbnbs</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
<span class="c1"># Plot POIs in red</span>
<span class="n">pois</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
<span class="c1"># Add Stamen&#39;s Toner basemap</span>
<span class="n">contextily</span><span class="o">.</span><span class="n">add_basemap</span><span class="p">(</span>
    <span class="n">ax</span><span class="p">,</span>
    <span class="n">crs</span><span class="o">=</span><span class="n">airbnbs</span><span class="o">.</span><span class="n">crs</span><span class="o">.</span><span class="n">to_string</span><span class="p">(),</span>
    <span class="n">source</span><span class="o">=</span><span class="n">contextily</span><span class="o">.</span><span class="n">providers</span><span class="o">.</span><span class="n">Stamen</span><span class="o">.</span><span class="n">Toner</span><span class="p">,</span>
<span class="p">)</span>
<span class="c1"># Remove axes</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
<span class="c1"># Display</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/783edd88cab5304fe758d6e3bfde51506cb60489810925ea60ba1f35fe67cdf1.png" src="../_images/783edd88cab5304fe758d6e3bfde51506cb60489810925ea60ba1f35fe67cdf1.png" />
</div>
</div>
<p>Now for some feature engineering. It may be extremely useful to know whether an Airbnb is located in a “hot” location, with a lot of restaurants and bars to choose from. Alternatively, if Airbnbs are very remote, they might not be as lucrative for short, expensive “city-break” reservations. That is, Airbnb users may decide to reserve stays where there are a lot of dining and drinking opportunities, and thus may be <em>willing to pay more</em> for the same accommodation. We might be able to predict prices better if we know about the drinking and dining scene near the Airbnb.</p>
<p>Thus, we can <em>engineer features</em> in the Airbnb data using the nearby POIs. To do this, we can create a new feature for the Airbnb dataset –that is, a new column in <code class="docutils literal notranslate"><span class="pre">airbnbs</span></code>– which incorporates information about how many POIs are <em>nearby</em> each property. This kind of “feature counting” is useful in applications where the mere presence of nearby features can affect the quantity we are modeling.</p>
<p>To do this kind of feature engineering, let us first walk through what we need to do at a conceptual level:</p>
<ol class="arabic simple">
<li><p>Decide what is <em>nearby</em>. This will dictate how far we go from each Airbnb when counting the number of “nearby” bars and restaurants. For this example, we will use a 500-meter buffer, which is approximately the distance of a leisurely ten-minute walk.</p></li>
<li><p>For each Airbnb, determine whether POIs are <em>within</em> a leisurely ten-minute walk.</p></li>
<li><p>Count how many POIs are within the specified radius of each Airbnb.</p></li>
</ol>
<p>At the end of this procedure, we have the number of bars and restaurants that are within a leisurely walk of the Airbnb, which might be useful in predicting the price of each Airbnb.</p>
<p>Let us now translate the list above into code. For part 1., we need to be able to measure distances in meters. However, <code class="docutils literal notranslate"><span class="pre">airbnbs</span></code> is originally expressed in degrees, since it is provided in terms of locations in latitude and longitude:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">airbnbs</span><span class="o">.</span><span class="n">crs</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;Geographic 2D CRS: EPSG:4326&gt;
Name: WGS 84
Axis Info [ellipsoidal]:
- Lat[north]: Geodetic latitude (degree)
- Lon[east]: Geodetic longitude (degree)
Area of Use:
- name: World.
- bounds: (-180.0, -90.0, 180.0, 90.0)
Datum: World Geodetic System 1984 ensemble
- Ellipsoid: WGS 84
- Prime Meridian: Greenwich
</pre></div>
</div>
</div>
</div>
<p>In addition, the <code class="docutils literal notranslate"><span class="pre">pois</span></code> are also provided in terms of their latitude and longitude:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pois</span><span class="o">.</span><span class="n">crs</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;Geographic 2D CRS: EPSG:4326&gt;
Name: WGS 84
Axis Info [ellipsoidal]:
- Lat[north]: Geodetic latitude (degree)
- Lon[east]: Geodetic longitude (degree)
Area of Use:
- name: World.
- bounds: (-180.0, -90.0, 180.0, 90.0)
Datum: World Geodetic System 1984 ensemble
- Ellipsoid: WGS 84
- Prime Meridian: Greenwich
</pre></div>
</div>
</div>
</div>
<p>Therefore, we need to convert this into a coordinate system that is easier to work with. Here, we will use a projection common for mapping in California, the California Albers projection:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">airbnbs_albers</span> <span class="o">=</span> <span class="n">airbnbs</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">epsg</span><span class="o">=</span><span class="mi">3311</span><span class="p">)</span>
<span class="n">pois_albers</span> <span class="o">=</span> <span class="n">pois</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">epsg</span><span class="o">=</span><span class="mi">3311</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pois_albers</span><span class="o">.</span><span class="n">crs</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;Projected CRS: EPSG:3311&gt;
Name: NAD83(HARN) / California Albers
Axis Info [cartesian]:
- X[east]: Easting (metre)
- Y[north]: Northing (metre)
Area of Use:
- name: United States (USA) - California.
- bounds: (-124.45, 32.53, -114.12, 42.01)
Coordinate Operation:
- name: California Albers
- method: Albers Equal Area
Datum: NAD83 (High Accuracy Reference Network)
- Ellipsoid: GRS 1980
- Prime Meridian: Greenwich
</pre></div>
</div>
</div>
</div>
<p>With this, we can create the radius of 500 meters around each Airbnb. This is often called <em>buffering</em>, where a shape is dilated by a given radius.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">airbnbs_albers</span><span class="p">[</span><span class="s2">&quot;buffer_500m&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">airbnbs_albers</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Now, <code class="docutils literal notranslate"><span class="pre">abb_buffer</span></code> contains a 500-meter circle around each Airbnb.</p>
<p>Using these, we can count the number of POIs that are within these areas using a <em>spatial join</em>. Spatial joins link geometries based on spatial relationships (or predicates). Here, we need to know the relationship: <code class="docutils literal notranslate"><span class="pre">pois</span> <span class="pre">within</span> <span class="pre">airbnb_buffers</span></code>, where <code class="docutils literal notranslate"><span class="pre">within</span></code> is the predicate relating <code class="docutils literal notranslate"><span class="pre">pois</span></code> to <code class="docutils literal notranslate"><span class="pre">airbnb_buffers</span></code>. Predicates are not always <em>reversible</em>: no <code class="docutils literal notranslate"><span class="pre">airbnb_buffer</span></code> can be <code class="docutils literal notranslate"><span class="pre">within</span></code> a <code class="docutils literal notranslate"><span class="pre">poi</span></code>. In <code class="docutils literal notranslate"><span class="pre">geopandas</span></code>, we can compute all pairs of relations between the <code class="docutils literal notranslate"><span class="pre">pois</span></code> and <code class="docutils literal notranslate"><span class="pre">airbnb_buffers</span></code> efficiently using the <code class="docutils literal notranslate"><span class="pre">sjoin</span></code> function, which takes a <code class="docutils literal notranslate"><span class="pre">predicate</span></code> argument defining the requested relationship between the first and second argument.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Spatial join, appending attributes from right table to left one</span>
<span class="n">joined</span> <span class="o">=</span> <span class="n">geopandas</span><span class="o">.</span><span class="n">sjoin</span><span class="p">(</span>
    <span class="c1"># Right table - POIs</span>
    <span class="n">pois_albers</span><span class="p">,</span>
    <span class="c1"># Left table - Airbnb with the geometry reset from the original</span>
    <span class="c1"># points to the 500-meter buffer and selecting only `id` and</span>
    <span class="c1"># `buffer_500m` column</span>
    <span class="n">airbnbs_albers</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span><span class="s2">&quot;buffer_500m&quot;</span><span class="p">)[[</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;buffer_500m&quot;</span><span class="p">]],</span>
    <span class="c1"># Operation (spatial predicate) to use for the spatial join (`within`)</span>
    <span class="n">op</span><span class="o">=</span><span class="s2">&quot;within&quot;</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>/opt/conda/lib/python3.10/site-packages/IPython/core/interactiveshell.py:3445: FutureWarning: The `op` parameter is deprecated and will be removed in a future release. Please use the `predicate` parameter instead.
  if await self.run_code(code, result, async_=asy):
</pre></div>
</div>
</div>
</div>
<p>The resulting <code class="docutils literal notranslate"><span class="pre">joined</span></code> object contains a row for every pair of POI and Airbnb that are linked. From there, we can apply a group-by operation, using the Airbnb ID, and count how many POIs each Airbnb has within 500 meters of distance:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Group POIs by Airbnb ID (`id`)</span>
<span class="n">poi_count</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">joined</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span>
        <span class="s2">&quot;id&quot;</span>
        <span class="c1"># Keep only POI id column (`osmid`)</span>
    <span class="p">)[</span>
        <span class="s2">&quot;osmid&quot;</span>
        <span class="c1"># Count POIs by Airbnb + convert Series into DataFrame</span>
    <span class="p">]</span>
    <span class="o">.</span><span class="n">count</span><span class="p">()</span>
    <span class="o">.</span><span class="n">to_frame</span><span class="p">(</span><span class="s2">&quot;poi_count&quot;</span><span class="p">)</span>
<span class="p">)</span>
<span class="c1"># Print top of the table</span>
<span class="n">poi_count</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>poi_count</th>
    </tr>
    <tr>
      <th>id</th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>6</th>
      <td>12</td>
    </tr>
    <tr>
      <th>5570</th>
      <td>7</td>
    </tr>
    <tr>
      <th>9553</th>
      <td>12</td>
    </tr>
    <tr>
      <th>38245</th>
      <td>1</td>
    </tr>
    <tr>
      <th>69385</th>
      <td>8</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>The resulting <code class="docutils literal notranslate"><span class="pre">Series</span></code> is indexed on the Airbnb IDs, so we can assign it to the original <code class="docutils literal notranslate"><span class="pre">airbnbs</span></code> table. In this case, we know by construction that missing Airbnbs in <code class="docutils literal notranslate"><span class="pre">poi_count</span></code> do not have any POI within 500m, so we can fill missing values in the column with zeros.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">airbnbs_w_counts</span> <span class="o">=</span> <span class="n">airbnbs_albers</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
    <span class="n">poi_count</span><span class="p">,</span> <span class="n">left_on</span><span class="o">=</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="n">right_index</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">({</span><span class="s2">&quot;poi_count&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
</pre></div>
</div>
</div>
</div>
<p>We can visualize now (Fig. XXX3XXX) the distribution of counts to get a sense of how “well-served” Airbnb properties are arranged over space:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set up figure and axis</span>
<span class="n">f</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">))</span>
<span class="c1"># Plot quantile map of No. of POIs for every Airbnb</span>
<span class="n">airbnbs_w_counts</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
    <span class="n">column</span><span class="o">=</span><span class="s2">&quot;poi_count&quot;</span><span class="p">,</span>
    <span class="n">scheme</span><span class="o">=</span><span class="s2">&quot;quantiles&quot;</span><span class="p">,</span>
    <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
    <span class="n">legend</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
<span class="p">)</span>
<span class="c1"># Add basemap</span>
<span class="n">contextily</span><span class="o">.</span><span class="n">add_basemap</span><span class="p">(</span>
    <span class="n">ax</span><span class="p">,</span>
    <span class="n">crs</span><span class="o">=</span><span class="n">airbnbs_albers</span><span class="o">.</span><span class="n">crs</span><span class="o">.</span><span class="n">to_string</span><span class="p">(),</span>
    <span class="n">source</span><span class="o">=</span><span class="n">contextily</span><span class="o">.</span><span class="n">providers</span><span class="o">.</span><span class="n">Stamen</span><span class="o">.</span><span class="n">Toner</span><span class="p">,</span>
<span class="p">)</span>
<span class="c1"># Remove axes</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/42d42c3e0079e56cecf6c61056875662fc2024a99b8491e28f3110c0edd70f75.png" src="../_images/42d42c3e0079e56cecf6c61056875662fc2024a99b8491e28f3110c0edd70f75.png" />
</div>
</div>
</section>
<section id="assigning-point-values-from-surfaces-elevation-of-airbnbs">
<h3>Assigning point values from surfaces: elevation of Airbnbs<a class="headerlink" href="#assigning-point-values-from-surfaces-elevation-of-airbnbs" title="Permalink to this headline">#</a></h3>
<p>We have just seen how to count points around each observation in a point dataset. In other cases, we might be confronted with a related but different challenge: transferring the value of a particular point in a surface to a point in a different dataset.</p>
<p>To make this more accessible, let us illustrate the context with an example question: <em>what is the elevation of each Airbnb property?</em> To answer this question, we require, at least, the following:</p>
<ol class="arabic simple">
<li><p>A sample of Airbnb property locations.</p></li>
<li><p>A dataset of elevation. We will use here the <a class="reference internal" href="../data/nasadem/README.html"><span class="doc std std-doc">NASA DEM</span></a> surface for the San Diego area.</p></li>
</ol>
<p>We use the code below, which opens and plot the file with elevation data, to generate Figure XXX4XXX:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Open file</span>
<span class="n">dem</span> <span class="o">=</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;../data/nasadem/nasadem_sd.tif&quot;</span><span class="p">)</span>
<span class="c1"># Set up figure and axis</span>
<span class="n">f</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="c1"># Display elevation data on created axis</span>
<span class="n">rioshow</span><span class="p">(</span><span class="n">dem</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
<span class="c1"># Remove axes</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/2e4df23e56d71791ce1d3861198f5d71a270b691d49698795c531981eb1696c8.png" src="../_images/2e4df23e56d71791ce1d3861198f5d71a270b691d49698795c531981eb1696c8.png" />
</div>
</div>
<p>Let’s first check the CRS is aligned with our sample of point locations:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dem</span><span class="o">.</span><span class="n">crs</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>CRS.from_epsg(4326)
</pre></div>
</div>
</div>
</div>
<p>We have opened the file with <code class="docutils literal notranslate"><span class="pre">rasterio</span></code>, which has not read the entire dataset just yet. This feature allows us to use this approach with files that are potentially very large, as only requested data is read into memory. To extract a discrete set of values from the elevation surface in <code class="docutils literal notranslate"><span class="pre">dem</span></code>, we can use <code class="docutils literal notranslate"><span class="pre">sample</span></code>. For a single location, this is how it works:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">list</span><span class="p">(</span><span class="n">dem</span><span class="o">.</span><span class="n">sample</span><span class="p">([(</span><span class="o">-</span><span class="mf">117.24592208862305</span><span class="p">,</span> <span class="mf">32.761619109301606</span><span class="p">)]))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[array([7], dtype=int16)]
</pre></div>
</div>
</div>
</div>
<p>Now, we can  apply this logic to a sequence of coordinates. For that, we need to extract them from the <code class="docutils literal notranslate"><span class="pre">geometry</span></code> object:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create table with XY coordinates of Airbnb locations</span>
<span class="n">abb_xys</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
    <span class="p">{</span><span class="s2">&quot;X&quot;</span><span class="p">:</span> <span class="n">airbnbs</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">:</span> <span class="n">airbnbs</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">y</span><span class="p">}</span>
    <span class="c1"># Convert from DataFrame to array of XY pairs</span>
<span class="p">)</span><span class="o">.</span><span class="n">to_records</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>And then we can apply the same logic as above to sample elevation for the list of Airbnb locations:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Save results as a DataFrame</span>
<span class="n">elevation</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
    <span class="c1"># Sequence of elevation measurements sampled at the Airbnb locations</span>
    <span class="n">dem</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">abb_xys</span><span class="p">),</span>
    <span class="c1"># Name of the column to be created to store elevation</span>
    <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Elevation&quot;</span><span class="p">],</span>
    <span class="c1"># Row index, mirroring that of Airbnb locations</span>
    <span class="n">index</span><span class="o">=</span><span class="n">airbnbs</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
<span class="p">)</span>
<span class="c1"># Print top of the table</span>
<span class="n">elevation</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Elevation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>112</td>
    </tr>
    <tr>
      <th>1</th>
      <td>3</td>
    </tr>
    <tr>
      <th>2</th>
      <td>99</td>
    </tr>
    <tr>
      <th>3</th>
      <td>114</td>
    </tr>
    <tr>
      <th>4</th>
      <td>30</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>Now that we have a table with the elevation of each Airbnb property, we can plot the site elevations on a map (Fig. XXX5XXX) for visual inspection:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set up figure and axis</span>
<span class="n">f</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">))</span>
<span class="c1"># Join elevation data to original Airbnb table</span>
<span class="n">airbnbs</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
    <span class="n">elevation</span>
    <span class="c1"># Plot elevation at each Airbnb location as a quantile choropleth</span>
<span class="p">)</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
    <span class="n">column</span><span class="o">=</span><span class="s2">&quot;Elevation&quot;</span><span class="p">,</span>
    <span class="n">scheme</span><span class="o">=</span><span class="s2">&quot;quantiles&quot;</span><span class="p">,</span>
    <span class="n">legend</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
    <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
<span class="p">)</span>
<span class="c1"># Add Stamen&#39;s terrain basemap</span>
<span class="n">contextily</span><span class="o">.</span><span class="n">add_basemap</span><span class="p">(</span>
    <span class="n">ax</span><span class="p">,</span>
    <span class="n">crs</span><span class="o">=</span><span class="n">airbnbs</span><span class="o">.</span><span class="n">crs</span><span class="o">.</span><span class="n">to_string</span><span class="p">(),</span>
    <span class="n">source</span><span class="o">=</span><span class="n">contextily</span><span class="o">.</span><span class="n">providers</span><span class="o">.</span><span class="n">Stamen</span><span class="o">.</span><span class="n">TerrainBackground</span><span class="p">,</span>
    <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
<span class="p">)</span>
<span class="c1"># Remove axes</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/702dbf9ea8f175f7d48f6313415aeb6a3ea5355b744ac90a1311f87565b8b298.png" src="../_images/702dbf9ea8f175f7d48f6313415aeb6a3ea5355b744ac90a1311f87565b8b298.png" />
</div>
</div>
</section>
<section id="point-interpolation-using-scikit-learn">
<h3>Point interpolation using scikit-learn<a class="headerlink" href="#point-interpolation-using-scikit-learn" title="Permalink to this headline">#</a></h3>
<p>In the previous example, we have transferred information from a surface (stored in a raster layer) to a set of points; in other words, we have gone from surface to points. Sometimes, however, we do not have the luxury of a ready-made surface. Instead, all we have available is a set of points with measurements for the variable of interest that do not match the points we want the information for. In this situation, a solution we can rely on is <em>spatial interpolation</em>. For a continuous geographical field measured at a set of points, <em>spatial interpolation</em> methods provide us a way to guess at the value a field would take at sites we do not measure.</p>
<p>There are many sophisticated methods with which this can be done. <em>Kriging</em>, common in the sub-field of spatial statistics called “geostatistics”, is one such practice based on the theory of <em>Gaussian Process Regression.</em> Another common approach, <em>geographically weighted regression</em>, provides unique model estimates at every control point, as well as predictions for places where there is no data. Here, though, we’ll use a fairly basic <span class="math notranslate nohighlight">\(k\)</span>-nearest neighbor prediction algorithm from <code class="docutils literal notranslate"><span class="pre">scikit-learn</span></code> to demonstrate the process.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">KNeighborsRegressor</span>
</pre></div>
</div>
</div>
</div>
<p>This algorithm will select the nearest ten listings, then compute the prediction using a weighted average of these nearest observations. To keep predictions relatively consistent, we will build an interpolation only for listings that are entire homes/apartments with two bedrooms:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">two_bed_homes</span> <span class="o">=</span> <span class="n">airbnbs</span><span class="p">[</span>
    <span class="n">airbnbs</span><span class="p">[</span><span class="s2">&quot;bedrooms&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;</span> <span class="n">airbnbs</span><span class="p">[</span><span class="s2">&quot;rt_Entire_home/apt&quot;</span><span class="p">]</span>
<span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>Once subset, we can extract the XY coordinates for each of them into a two-dimensional array:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">two_bed_home_locations</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">column_stack</span><span class="p">(</span>
    <span class="p">(</span><span class="n">two_bed_homes</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">two_bed_homes</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>To plot the interpolated surface, we must also construct a grid of locations for which we will make predictions. This can be done using <code class="docutils literal notranslate"><span class="pre">numpy.meshgrid</span></code>, which constructs all the combinations of the input dimensions as a grid of outputs.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Extract bounding box of Airbnb locations</span>
<span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="n">airbnbs</span><span class="o">.</span><span class="n">total_bounds</span>
<span class="c1"># Generate X and Y meshes for the space within the bounding box</span>
<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span>
    <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>To build an intuition on what they are we create Figure XXX6XXX, which visualizes both meshes side-by-side:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set up figure</span>
<span class="n">f</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1"># Plot X mesh</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="c1"># Plot Y mesh</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="c1"># Label X mesh</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;X values&quot;</span><span class="p">)</span>
<span class="c1"># Label Y mesh</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Y values&quot;</span><span class="p">)</span>
<span class="c1"># Display</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/3ca539b0c5ed463286fc4881f4d0a922a8c1ac0ef9f530a8e5b9f94daa59ec2f.png" src="../_images/3ca539b0c5ed463286fc4881f4d0a922a8c1ac0ef9f530a8e5b9f94daa59ec2f.png" />
</div>
</div>
<p>With these coordinates, we can make a GeoDataFrame containing the grid cells at which we would like to predict:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Bind a 1D (flattened) of X and Y meshes into a 2D array</span>
<span class="n">grid</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">flatten</span><span class="p">()))</span>
<span class="c1"># Convert a 1D (flattened) version of X and Y meshes into a geo-table</span>
<span class="n">grid_df</span> <span class="o">=</span> <span class="n">geopandas</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span>
    <span class="n">geometry</span><span class="o">=</span><span class="n">geopandas</span><span class="o">.</span><span class="n">points_from_xy</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We can visualize this grid together with the original Airbnb locations (Fig. XXX7XXX) to get a better sense of what we have just built:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Plot grid points with size 1</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">grid_df</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">markersize</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="c1"># Plot on top Airbnb locations in red</span>
<span class="n">two_bed_homes</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">)</span>
<span class="c1"># Add basemap</span>
<span class="n">contextily</span><span class="o">.</span><span class="n">add_basemap</span><span class="p">(</span>
    <span class="n">ax</span><span class="p">,</span>
    <span class="n">crs</span><span class="o">=</span><span class="n">two_bed_homes</span><span class="o">.</span><span class="n">crs</span><span class="o">.</span><span class="n">to_string</span><span class="p">(),</span>
    <span class="n">source</span><span class="o">=</span><span class="n">contextily</span><span class="o">.</span><span class="n">providers</span><span class="o">.</span><span class="n">Stamen</span><span class="o">.</span><span class="n">TonerBackground</span><span class="p">,</span>
<span class="p">)</span>
<span class="c1"># Remove axes</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/e30824d60e790640d99a70f79d23c1548aebb54fd54bbdef7a080c68f7a9b089.png" src="../_images/e30824d60e790640d99a70f79d23c1548aebb54fd54bbdef7a080c68f7a9b089.png" />
</div>
</div>
<p>With this done, we can now construct the predictions. First we train the model:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">KNeighborsRegressor</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="s2">&quot;distance&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
    <span class="n">two_bed_home_locations</span><span class="p">,</span> <span class="n">two_bed_homes</span><span class="o">.</span><span class="n">price</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>And then we predict at the grid cell locations:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">predictions</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The result can be displayed as a continuous choropleth (Fig. XXX8XXX), for example:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ax</span> <span class="o">=</span> <span class="n">grid_df</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">predictions</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/abe5a2a55380427983c5e1c2a6ca2cfaf9b8b004e0b888bafb0e57b5fbc8d3a8.png" src="../_images/abe5a2a55380427983c5e1c2a6ca2cfaf9b8b004e0b888bafb0e57b5fbc8d3a8.png" />
</div>
</div>
<p>The map is a result not only of the underlying data but also the algorithm we have used. For example, you can see in Figure XXX9XXX (generated with the code below) that the surface gets smoother as you increase the number of nearest neighbors to consider.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set up figure and 8 axes</span>
<span class="n">f</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="c1"># Loop over eight values equally spaced between 2 and 100</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">k_neighbors</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
    <span class="n">numpy</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="p">):</span>
    <span class="c1"># Select axis to plot estimates for that value of k</span>
    <span class="n">facet</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="c1"># Set up a KNN regressor instance with k_neighbors neighbors</span>
    <span class="n">predictions</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">KNeighborsRegressor</span><span class="p">(</span>
            <span class="n">n_neighbors</span><span class="o">=</span><span class="n">k_neighbors</span><span class="p">,</span>
            <span class="n">weights</span><span class="o">=</span><span class="s2">&quot;distance&quot;</span>
            <span class="c1"># Fit instance to the 2-bed subset</span>
        <span class="p">)</span>
        <span class="o">.</span><span class="n">fit</span><span class="p">(</span>
            <span class="n">two_bed_home_locations</span><span class="p">,</span>
            <span class="n">two_bed_homes</span><span class="o">.</span><span class="n">price</span>
            <span class="c1"># Get predictions for locations on the grid</span>
        <span class="p">)</span>
        <span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="c1"># Plot predictions</span>
    <span class="n">grid_df</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">predictions</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">facet</span><span class="p">)</span>
    <span class="c1"># Remove axis</span>
    <span class="n">facet</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;off&quot;</span><span class="p">)</span>
    <span class="c1"># Set axis title</span>
    <span class="n">facet</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k_neighbors</span><span class="si">}</span><span class="s2"> neighbors&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/ba243c8f14529ed36d7b41c6ce018e947e8df30d6f279d512a846118a70d91c3.png" src="../_images/ba243c8f14529ed36d7b41c6ce018e947e8df30d6f279d512a846118a70d91c3.png" />
</div>
</div>
<p>Focusing in on central San Diego tells the story a bit more clearly, since there are interesting points there to show. The increasing number of nearest neighbors increases the smoothness of the interpolated surface. To visualize a zoom into the region, we begin by extracting its bounding box:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">central_sd_bounds</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">117.179832</span><span class="p">,</span> <span class="mf">32.655563</span><span class="p">,</span> <span class="o">-</span><span class="mf">117.020874</span><span class="p">,</span> <span class="mf">32.769909</span><span class="p">]</span>
<span class="p">(</span>
    <span class="n">central_xmin</span><span class="p">,</span>
    <span class="n">central_ymin</span><span class="p">,</span>
    <span class="n">central_xmax</span><span class="p">,</span>
    <span class="n">central_ymax</span><span class="p">,</span>
<span class="p">)</span> <span class="o">=</span> <span class="n">central_sd_bounds</span>
</pre></div>
</div>
</div>
</div>
<p>And repeating the process above for this area, including building the meshes of coordinates:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Build X and Y meshes</span>
<span class="n">central_x</span><span class="p">,</span> <span class="n">central_y</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span>
    <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">central_xmin</span><span class="p">,</span> <span class="n">central_xmax</span><span class="p">),</span>
    <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">central_ymin</span><span class="p">,</span> <span class="n">central_ymax</span><span class="p">),</span>
<span class="p">)</span>
<span class="c1"># Bind X and Y meshes in a 2D array</span>
<span class="n">central_grid</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">column_stack</span><span class="p">(</span>
    <span class="p">(</span><span class="n">central_x</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">central_y</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
<span class="p">)</span>
<span class="c1"># Bind X and Y meshes in a geo-table</span>
<span class="n">central_grid_df</span> <span class="o">=</span> <span class="n">geopandas</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span>
    <span class="n">geometry</span><span class="o">=</span><span class="n">geopandas</span><span class="o">.</span><span class="n">points_from_xy</span><span class="p">(</span>
        <span class="n">x</span><span class="o">=</span><span class="n">central_x</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">y</span><span class="o">=</span><span class="n">central_y</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Finally, we can reproduce the sequence of figures with different values of K only for the central part of the San Diego area (Fig. XXX10XXX):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set up figure and subplot</span>
<span class="n">f</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sharey</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="c1"># Loop over five values equally spaced between 2 and 100</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">k_neighbors</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
    <span class="n">numpy</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="p">):</span>
    <span class="c1"># Select axis to plot estimates for that value of k</span>
    <span class="n">facet</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="c1"># Set up a KNN regressor instance with k_neighbors neighbors</span>
    <span class="n">predictions</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">KNeighborsRegressor</span><span class="p">(</span>
            <span class="n">n_neighbors</span><span class="o">=</span><span class="n">k_neighbors</span><span class="p">,</span>
            <span class="n">weights</span><span class="o">=</span><span class="s2">&quot;distance&quot;</span>
            <span class="c1"># Fit instance to the 2-bed subset</span>
        <span class="p">)</span>
        <span class="o">.</span><span class="n">fit</span><span class="p">(</span>
            <span class="n">two_bed_home_locations</span><span class="p">,</span>
            <span class="n">two_bed_homes</span><span class="o">.</span><span class="n">price</span>
            <span class="c1"># Get predictions for locations on the grid</span>
        <span class="p">)</span>
        <span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">central_grid</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="c1"># Plot predictions</span>
    <span class="n">central_grid_df</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">predictions</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">facet</span><span class="p">)</span>
    <span class="c1"># Remove axis</span>
    <span class="n">facet</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;off&quot;</span><span class="p">)</span>
    <span class="c1"># Set axis title</span>
    <span class="n">facet</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k_neighbors</span><span class="si">}</span><span class="s2"> neighbors&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/621d8b686ff987ba54c8c7c03e23530303dcc14b19082030471c08563adbf4a8.png" src="../_images/621d8b686ff987ba54c8c7c03e23530303dcc14b19082030471c08563adbf4a8.png" />
</div>
</div>
<p>Plenty more of these methods are implemented in <code class="docutils literal notranslate"><span class="pre">scikit-learn.neighbors</span></code>, as well as kriging methods in <code class="docutils literal notranslate"><span class="pre">GSTools</span></code> <span id="id1">[<a class="reference internal" href="references.html#id81" title="Sebastian Müller and Lennart Schüler. Geostat-framework/gstools: v1.3.3 'pure pink'. August 2021. URL: https://doi.org/10.5281/zenodo.5169658, doi:10.5281/zenodo.5169658.">MS21</a>]</span> and geographically weighted regression in <code class="docutils literal notranslate"><span class="pre">mgwr</span></code> <span id="id2">[<a class="reference internal" href="references.html#id79" title="Taylor M Oshan, Ziqi Li, Wei Kang, Levi J Wolf, and A Stewart Fotheringham. Mgwr: a python implementation of multiscale geographically weighted regression for investigating process spatial heterogeneity and scale. ISPRS International Journal of Geo-Information, 8(6):269, 2019.">OLK+19</a>]</span>.</p>
</section>
<section id="polygon-to-point">
<h3>Polygon to point<a class="headerlink" href="#polygon-to-point" title="Permalink to this headline">#</a></h3>
<p>We now move on to a case where the information we are interested in matching to our set of points is stored in a polygon geography. For example, we would like to know the population density of the neighborhood in which each Airbnb is located. This is conceptually similar to the sampling example above, but in the case the information we want to sample is not a surface but a geo-table of polygons. To determine density, we will download population estimates at the census tract level, and “transfer” those estimates over to each Airbnb point. Geographically, the only challenge here is finding the containing polygon for each point, and then performing what is in spatial databases parlance known as a “spatial join”, by which we link the two layers through their spatial connection.</p>
<p>Let us pull down the number of inhabitants from the American Community Survey for tracts in San Diego:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">acs</span> <span class="o">=</span> <span class="n">cenpy</span><span class="o">.</span><span class="n">products</span><span class="o">.</span><span class="n">ACS</span><span class="p">()</span>
    <span class="n">sd_pop</span> <span class="o">=</span> <span class="n">acs</span><span class="o">.</span><span class="n">from_msa</span><span class="p">(</span>
        <span class="s2">&quot;San Diego, CA&quot;</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s2">&quot;tract&quot;</span><span class="p">,</span> <span class="n">variables</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;B02001_001E&quot;</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">sd_pop</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="s2">&quot;../data/cache/sd_census.gpkg&quot;</span><span class="p">,</span> <span class="n">driver</span><span class="o">=</span><span class="s1">&#39;GPKG&#39;</span><span class="p">)</span>
<span class="k">except</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Remote loading failed...&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>/opt/conda/lib/python3.10/site-packages/cenpy/products.py:748: FutureWarning: The `op` parameter is deprecated and will be removed in a future release. Please use the `predicate` parameter instead.
  return self._from_name(
</pre></div>
</div>
</div>
</div>
<p>The code snippet above sends a query to the Census Bureau server to fetch the data for San Diego. Note that it <em>requires</em> internet connectivity to work. If you are working on the book <em>without</em> connectivity, a cached version of the dataset is available on the data folder and can be read as:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sd_pop</span> <span class="o">=</span> <span class="n">geopandas</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s2">&quot;../data/cache/sd_census.gpkg&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>And calculate population density:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sd_pop</span><span class="p">[</span><span class="s2">&quot;density&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">sd_pop</span><span class="p">[</span><span class="s2">&quot;B02001_001E&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">sd_pop</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">epsg</span><span class="o">=</span><span class="mi">3311</span><span class="p">)</span><span class="o">.</span><span class="n">area</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Now, to “transfer” density estimates to each Airbnb, we can rely on the spatial join in <code class="docutils literal notranslate"><span class="pre">geopandas</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">j</span> <span class="o">=</span> <span class="n">geopandas</span><span class="o">.</span><span class="n">sjoin</span><span class="p">(</span><span class="n">airbnbs</span><span class="p">,</span> <span class="n">sd_pop</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">airbnbs</span><span class="o">.</span><span class="n">crs</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>The result is a table with one row per Airbnb and one column for each attribute we originally had for properties, <em>as well as</em> those of the tract where the area is located:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">j</span><span class="o">.</span><span class="n">info</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;class &#39;geopandas.geodataframe.GeoDataFrame&#39;&gt;
Int64Index: 6110 entries, 0 to 6068
Data columns (total 28 columns):
 #   Column              Non-Null Count  Dtype   
---  ------              --------------  -----   
 0   accommodates        6110 non-null   int64   
 1   bathrooms           6110 non-null   float64 
 2   bedrooms            6110 non-null   float64 
 3   beds                6110 non-null   float64 
 4   neighborhood        6110 non-null   object  
 5   pool                6110 non-null   int64   
 6   d2balboa            6110 non-null   float64 
 7   coastal             6110 non-null   int64   
 8   price               6110 non-null   float64 
 9   log_price           6110 non-null   float64 
 10  id                  6110 non-null   int64   
 11  pg_Apartment        6110 non-null   int64   
 12  pg_Condominium      6110 non-null   int64   
 13  pg_House            6110 non-null   int64   
 14  pg_Other            6110 non-null   int64   
 15  pg_Townhouse        6110 non-null   int64   
 16  rt_Entire_home/apt  6110 non-null   int64   
 17  rt_Private_room     6110 non-null   int64   
 18  rt_Shared_room      6110 non-null   int64   
 19  geometry            6110 non-null   geometry
 20  index_right         6110 non-null   int64   
 21  GEOID               6110 non-null   object  
 22  B02001_001E         6110 non-null   float64 
 23  NAME                6110 non-null   object  
 24  state               6110 non-null   object  
 25  county              6110 non-null   object  
 26  tract               6110 non-null   object  
 27  density             6110 non-null   float64 
dtypes: float64(8), geometry(1), int64(13), object(6)
memory usage: 1.4+ MB
</pre></div>
</div>
</div>
</div>
</section>
<section id="area-to-area-interpolation">
<h3>Area to area interpolation<a class="headerlink" href="#area-to-area-interpolation" title="Permalink to this headline">#</a></h3>
<p>The final case of map matching we consider is transfer of information from one polygon/areal geography to a different one. This is a common use-case when an analysis requires data that is provided at different levels of aggregation and different boundary delineations.</p>
<p>There is a large literature around this problem under the umbrella of dasymetric mapping <span id="id3">[<a class="reference internal" href="references.html#id71" title="Cory L Eicher and Cynthia A Brewer. Dasymetric mapping and areal interpolation: implementation and evaluation. Cartography and Geographic Information Science, 28(2):125–138, 2001.">EB01</a>]</span>. The conceptual idea is relatively straightforward: we want to apportion values from one set of polygons to another based on how much “geography” is shared. In its simplest case, we can do this based on area. We will assign values from the former geography to the latter one based on how much they share. Let us illustrate this with an example. We will call the geography for which we have data the “source”, and that to which we want to transfer data the “target”. Let’s say we have a population count  measure for each of three source polygons, 1, 2, 3, and we have a target polygon A for which we require an estimated population. If the intersection of polygon A with each of the source polygons amounts to  50%, 30%, and 20% of the total area of polygon A, respectively, then the population estimate for A will be a weighted average between the rates in 1, 2, and 3, where the weights are 0.5, 0.3, and 0.2, respectively.</p>
<p>We could also go in the other direction. If we had total population for polygon A, but population was not reported for polygons 1, 2, 3, we could use areal interpolation to allocate the population from A (now the source polygon) to each of the three target polygons. Polygon 1 would get 0.5 of the population of A, polygon 2 would get 0.3 of A’s population, and C the remainder. Here we are assuming the area of A is completely exhausted by the areas of 1, 2, and 3, and that the latter polygons do not overlap with each other. Of course, underlying this exercise is the implicit assumption that the values we are interested in are uniformly distributed within each polygon in the source and target. In some cases, this is a valid assumption or, at least, it does not introduce critical errors; in others, this is not acceptable. Dasymetric mapping has proposed a large amount of sophistications that try to come up with more realistic estimates and that can incorporate additional information.</p>
<p>To implement dasymetric mapping in Python, the best option is <code class="docutils literal notranslate"><span class="pre">tobler</span></code>, a package from the Pysal federation designed exactly for this goal. We will show here the simplest case, that of areal interpolation where apportioning is estimated based on area, but the package also provides more sophisticated approaches.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">tobler.area_weighted</span> <span class="kn">import</span> <span class="n">area_interpolate</span>
</pre></div>
</div>
</div>
</div>
<p>For the example, we need two polygon layers. We will stick with San Diego and use the set of Census Tracts read above, and a grid layer built using the H3 hexagonal spatial index <span id="id4">[<a class="reference internal" href="references.html#id63" title="Isaac Brodsky. H3: uber’s hexagonal hierarchical spatial index. Available from Uber Engineering website: https://eng. uber. com/h3/[22 June 2019], 2018.">Bro18</a>]</span>. Our goal will be to create population estimates for each hexagonal cell.</p>
<p>First, let us load the H3 grid:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">h3</span> <span class="o">=</span> <span class="n">geopandas</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s2">&quot;../data/h3_grid/sd_h3_grid.gpkg&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We are ready to interpolate:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Area interpolation from polygon geotable to polygon geo-table</span>
<span class="n">interpolated</span> <span class="o">=</span> <span class="n">area_interpolate</span><span class="p">(</span>
    <span class="c1"># Source geo-table (converted to EPSG:3311 CRS)</span>
    <span class="n">source_df</span><span class="o">=</span><span class="n">sd_pop</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">epsg</span><span class="o">=</span><span class="mi">3311</span><span class="p">),</span>
    <span class="c1"># Target geo-table (converted to EPSG:3311 CRS)</span>
    <span class="n">target_df</span><span class="o">=</span><span class="n">h3</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">epsg</span><span class="o">=</span><span class="mi">3311</span><span class="p">),</span>
    <span class="c1"># Extensive variables in `source_df` to be interpolated (e.g. population)</span>
    <span class="n">extensive_variables</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;B02001_001E&quot;</span><span class="p">],</span>
    <span class="c1"># Intensive variables in `source_df` to be interpolated (e.g. density)</span>
    <span class="n">intensive_variables</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;density&quot;</span><span class="p">],</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>There is quite a bit going on in the cell above, let us unpack it:</p>
<ul class="simple">
<li><p>Remember this method apportions data values based on area, so it makes sense to have an accurate estimate for the extent of each polygon. To do that, we convert each geography to Albers Equal (<code class="docutils literal notranslate"><span class="pre">EPSG:3311</span></code>), which is expressed in meters, using <code class="docutils literal notranslate"><span class="pre">to_crs</span></code>.</p></li>
<li><p>The method <code class="docutils literal notranslate"><span class="pre">area_interpolate</span></code> then takes the source and the target <code class="docutils literal notranslate"><span class="pre">GeoDataFrame</span></code> objects using the same naming convention we have in our explanation.</p></li>
<li><p>In addition, we need to specify which variables we would like to interpolate. here, Tobler makes a distinction:</p>
<ul>
<li><p><em>Extensive</em> variables, or absolute values such as counts, aggregates, etc. (which we use for population, <code class="docutils literal notranslate"><span class="pre">B02001_001E</span></code>)</p></li>
<li><p><em>Intensive</em> variables, such as rates, ratios, etc. (which we select for density, as it is the ratio of population over area)</p></li>
</ul>
</li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">interpolated</span></code> output object is a geo-table that contains the target polygons and estimates of the variable(s) we originally had for the source geography (population and density in this case). Figure XXX11XXX (generated with the code below) illustrates the transfer of information from one geography to the other with for the case of total population estimates.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set up figure and axes</span>
<span class="n">f</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">18</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>

<span class="c1"># Extract bounding box from output for easier visual comparison</span>
<span class="n">minX</span><span class="p">,</span> <span class="n">minY</span><span class="p">,</span> <span class="n">maxX</span><span class="p">,</span> <span class="n">maxY</span> <span class="o">=</span> <span class="n">interpolated</span><span class="o">.</span><span class="n">total_bounds</span>
<span class="c1"># Reproject tracts to EPSG:331</span>
<span class="n">sd_pop</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span>
    <span class="n">epsg</span><span class="o">=</span><span class="mi">3311</span>
    <span class="c1"># Clip to the bounding box</span>
<span class="p">)</span><span class="o">.</span><span class="n">cx</span><span class="p">[</span>
    <span class="n">minX</span><span class="p">:</span><span class="n">maxX</span><span class="p">,</span>
    <span class="n">minY</span><span class="p">:</span><span class="n">maxY</span>
    <span class="c1"># Quantile choropleth for tract population</span>
<span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
    <span class="n">column</span><span class="o">=</span><span class="s2">&quot;B02001_001E&quot;</span><span class="p">,</span> <span class="n">scheme</span><span class="o">=</span><span class="s2">&quot;quantiles&quot;</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="p">)</span>
<span class="c1"># Remove axes</span>
<span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>

<span class="c1"># Reproject H3 hexagons to ESPG:3311</span>
<span class="n">h3</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span>
    <span class="n">epsg</span><span class="o">=</span><span class="mi">3311</span>
    <span class="c1"># Plot hexagons</span>
<span class="p">)</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">markersize</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="c1"># Remove axes</span>
<span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>

<span class="c1"># Plot hexagons with interpolated population</span>
<span class="n">interpolated</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
    <span class="n">column</span><span class="o">=</span><span class="s2">&quot;B02001_001E&quot;</span><span class="p">,</span> <span class="n">scheme</span><span class="o">=</span><span class="s2">&quot;quantiles&quot;</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">axs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="p">)</span>
<span class="c1"># Remove axes</span>
<span class="n">axs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>

<span class="c1"># Adjust limits of tract map to hexagons bounding box</span>
<span class="c1"># for easier visual comparison</span>
<span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">minX</span><span class="p">,</span> <span class="n">maxX</span><span class="p">)</span>
<span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">minY</span><span class="p">,</span> <span class="n">maxY</span><span class="p">)</span>
<span class="c1"># Display</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/fa2ba51fe5a6ef20e8a4b469a96d3f4495fa12dd31808bac821725bf55d280e7.png" src="../_images/fa2ba51fe5a6ef20e8a4b469a96d3f4495fa12dd31808bac821725bf55d280e7.png" />
</div>
</div>
<p>And Figure XXX12XXX, generated with the code below, shows the equivalent for population density.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set up figure and axes</span>
<span class="n">f</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">18</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>

<span class="c1"># Extract bounding box from output for easier visual comparison</span>
<span class="n">minX</span><span class="p">,</span> <span class="n">minY</span><span class="p">,</span> <span class="n">maxX</span><span class="p">,</span> <span class="n">maxY</span> <span class="o">=</span> <span class="n">interpolated</span><span class="o">.</span><span class="n">total_bounds</span>
<span class="c1"># Reproject tracts to EPSG:331</span>
<span class="n">sd_pop</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span>
    <span class="n">epsg</span><span class="o">=</span><span class="mi">3311</span>
    <span class="c1"># Clip to the bounding box</span>
<span class="p">)</span><span class="o">.</span><span class="n">cx</span><span class="p">[</span>
    <span class="n">minX</span><span class="p">:</span><span class="n">maxX</span><span class="p">,</span>
    <span class="n">minY</span><span class="p">:</span><span class="n">maxY</span>
    <span class="c1"># Quantile choropleth for tract population density</span>
<span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
    <span class="n">column</span><span class="o">=</span><span class="s2">&quot;density&quot;</span><span class="p">,</span> <span class="n">scheme</span><span class="o">=</span><span class="s2">&quot;quantiles&quot;</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="p">)</span>
<span class="c1"># Remove axes</span>
<span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>

<span class="c1"># Reproject H3 hexagons to ESPG:3311</span>
<span class="n">h3</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span>
    <span class="n">epsg</span><span class="o">=</span><span class="mi">3311</span>
    <span class="c1"># Plot hexagons</span>
<span class="p">)</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">markersize</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="c1"># Remove axes</span>
<span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>

<span class="c1"># Plot hexagons with interpolated population density</span>
<span class="n">interpolated</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
    <span class="n">column</span><span class="o">=</span><span class="s2">&quot;density&quot;</span><span class="p">,</span> <span class="n">scheme</span><span class="o">=</span><span class="s2">&quot;quantiles&quot;</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">axs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="p">)</span>
<span class="c1"># Remove axes</span>
<span class="n">axs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>

<span class="c1"># Adjust limits of tract map to hexagons bounding box</span>
<span class="c1"># for easier visual comparison</span>
<span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">minX</span><span class="p">,</span> <span class="n">maxX</span><span class="p">)</span>
<span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">minY</span><span class="p">,</span> <span class="n">maxY</span><span class="p">)</span>
<span class="c1"># Display</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/49bc794df4974850d3dc263bc79a4c7efb994f0bc54fdc4c7c333be9f30dd581.png" src="../_images/49bc794df4974850d3dc263bc79a4c7efb994f0bc54fdc4c7c333be9f30dd581.png" />
</div>
</div>
</section>
</section>
<section id="feature-engineering-using-map-synthesis">
<h2>Feature engineering using map synthesis<a class="headerlink" href="#feature-engineering-using-map-synthesis" title="Permalink to this headline">#</a></h2>
<p>Feature engineering with map matching is most helpful when you have additional information to use in the analysis. And, with the wealth of freely available data from censuses, satellites, and open volunteered geographic information vendors such as OpenStreetMap, map matching can be a very powerful tool for enriching and improving your analyses. However, it is sometimes <em>also</em> useful to only examine the data you’ve got, and use the spatial structure within to build better features or better models. While this might be done using spatially explicit models (like those covered in <a class="reference internal" href="11_regression.html"><span class="doc std std-doc">Chapter 11</span></a>), it is also possible to use map synthesis to build spatial features and improve model performance.</p>
<p>There is an extensive amount of map synthesis features. In fact, many of them are usually derived for specific use cases and following the intuition of domain experts that can take technical guidance along the lines presented here. We discuss two main ones as an illustration, but reiterate that the sky really is the limit in this category. First, we will return to spatial <em>summary</em> features. Second, we will examine <em>regionalization features</em>, which detect and leverage geographical clusters in the data to improve prediction.</p>
<section id="spatial-summary-features-in-map-synthesis">
<h3>Spatial summary features in map synthesis<a class="headerlink" href="#spatial-summary-features-in-map-synthesis" title="Permalink to this headline">#</a></h3>
<p>Just like in map matching, you can use spatial summary features in map synthesis to build better models. One approach involves constructing spatial summary measures of your training data. This is done in the same manner as in map matching, except we now refer only to the data on hand. Thus, we may want to determine whether nearby Airbnbs are “competing” with each Airbnb. We might do this by finding the distance to the nearest Airbnb with the same number of bedrooms, since two nearby listings that <em>also</em> sleep the same number of people likely will compete with one another for tenants.</p>
<section id="counting-neighbors">
<h4>Counting neighbors<a class="headerlink" href="#counting-neighbors" title="Permalink to this headline">#</a></h4>
<p>A useful metric to characterize an observation in your data through geography is whether it is surrounded by other observations or not. This question (and the following one we cover) is another area of geographic data science where spatial weights matrices are useful.</p>
<p>If we define to be “surrounded by other observations” as in “having many neighbors”, this translates into the cardinalities of a spatial weights matrix (i.e., the number of neighbors recorded in the matrix for each observation).</p>
<p>For example, we can “engineer a feature” that contains the number of Airbnb properties each property has within 500 meters by constructing a distance band object:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Build distance band spatial weights matrix</span>
<span class="n">d500_w</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">DistanceBand</span><span class="o">.</span><span class="n">from_dataframe</span><span class="p">(</span>
    <span class="n">airbnbs_albers</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">silence_warnings</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>And extracting its cardinalities:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">card</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">d500_w</span><span class="o">.</span><span class="n">cardinalities</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">card</span></code> feature we have built will pick up areas of higher concentration of Airbnb properties with higher values, as we can see in Figure XXX13XXX.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set up figure and axis</span>
<span class="n">f</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="c1"># Append cardinalities to main Airbnb geo-table</span>
<span class="n">airbnbs</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span>
    <span class="n">card</span><span class="o">=</span><span class="n">card</span>
    <span class="c1"># Plot cardinality quantile choropleth</span>
<span class="p">)</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="s2">&quot;card&quot;</span><span class="p">,</span> <span class="n">scheme</span><span class="o">=</span><span class="s2">&quot;quantiles&quot;</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
<span class="c1"># Add basemap</span>
<span class="n">contextily</span><span class="o">.</span><span class="n">add_basemap</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">airbnbs</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>
<span class="c1"># Remove axes</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/62b6521e017b380b27a0ef92b572072edab9572f427bc8c9bf2fe0dc579cd57a.png" src="../_images/62b6521e017b380b27a0ef92b572072edab9572f427bc8c9bf2fe0dc579cd57a.png" />
</div>
</div>
</section>
<section id="distance-buffers-within-a-single-table">
<h4>Distance buffers within a single table<a class="headerlink" href="#distance-buffers-within-a-single-table" title="Permalink to this headline">#</a></h4>
<p>If what we are interested in is finding the average number of bedrooms around each house, we might do this using a row-standardized version of the <code class="docutils literal notranslate"><span class="pre">DistanceBand</span></code> weight object we have just built, which considers Airbnb as “neighbors” if they are within the distance threshold, and computing the spatial lag of the number of bedrooms.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Row standardize</span>
<span class="n">d500_w</span><span class="o">.</span><span class="n">transform</span> <span class="o">=</span> <span class="s2">&quot;r&quot;</span>
<span class="c1"># Compute spatial lag of No. of bedrooms</span>
<span class="n">local_average_bedrooms</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">lag_spatial</span><span class="p">(</span>
    <span class="n">d500_w</span><span class="p">,</span> <span class="n">airbnbs_albers</span><span class="p">[[</span><span class="s2">&quot;bedrooms&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>While related, these features contain quite distinct pieces of information, and both may prove useful in modeling. This is shown in Figure XXX14XXX, which compares them directly in a scatterplot.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
    <span class="n">airbnbs_albers</span><span class="p">[[</span><span class="s2">&quot;bedrooms&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">local_average_bedrooms</span>
<span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Number of bedrooms&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Average of nearby</span><span class="se">\n</span><span class="s2"> listings&#39; bedrooms&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/16af35561f3dd700b927ff578c0cbbda002c277b12ede4bed8f2463749f46414.png" src="../_images/16af35561f3dd700b927ff578c0cbbda002c277b12ede4bed8f2463749f46414.png" />
</div>
</div>
<p>If we were instead interested in the most common number of bedrooms, rather than the average, we could use the <code class="docutils literal notranslate"><span class="pre">lag_categorical</span></code> function, which will consider each value as a category and return the most common value in each neighbor set:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">local_mode</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">lag_categorical</span><span class="p">(</span>
    <span class="n">d500_w</span><span class="p">,</span> <span class="n">airbnbs_albers</span><span class="p">[[</span><span class="s2">&quot;bedrooms&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>/opt/conda/lib/python3.10/site-packages/numpy/core/fromnumeric.py:3432: RuntimeWarning: Mean of empty slice.
  return _methods._mean(a, axis=axis, dtype=dtype,
/opt/conda/lib/python3.10/site-packages/numpy/core/_methods.py:190: RuntimeWarning: invalid value encountered in double_scalars
  ret = ret.dtype.type(ret / rcount)
</pre></div>
</div>
</div>
</div>
<p>Since we are now treating the number of bedrooms as a discrete feature, we can use a <code class="docutils literal notranslate"><span class="pre">crosstab</span></code> from <code class="docutils literal notranslate"><span class="pre">pandas</span></code> to examine the relationship between a listing and the typical size of listings nearby:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">crosstab</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">crosstab</span><span class="p">(</span>
    <span class="n">airbnbs_albers</span><span class="o">.</span><span class="n">bedrooms</span><span class="p">,</span> <span class="n">local_mode</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
<span class="p">)</span>
<span class="n">crosstab</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;nearby&quot;</span>
<span class="n">crosstab</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>nearby</th>
      <th>0.0</th>
      <th>1.0</th>
      <th>2.0</th>
      <th>3.0</th>
      <th>4.0</th>
      <th>5.0</th>
      <th>6.0</th>
    </tr>
    <tr>
      <th>bedrooms</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0.0</th>
      <td>5</td>
      <td>391</td>
      <td>39</td>
      <td>9</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1.0</th>
      <td>4</td>
      <td>3065</td>
      <td>214</td>
      <td>33</td>
      <td>18</td>
      <td>4</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2.0</th>
      <td>1</td>
      <td>978</td>
      <td>269</td>
      <td>11</td>
      <td>3</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3.0</th>
      <td>3</td>
      <td>427</td>
      <td>165</td>
      <td>34</td>
      <td>13</td>
      <td>2</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4.0</th>
      <td>0</td>
      <td>165</td>
      <td>57</td>
      <td>11</td>
      <td>32</td>
      <td>6</td>
      <td>2</td>
    </tr>
    <tr>
      <th>5.0</th>
      <td>0</td>
      <td>51</td>
      <td>17</td>
      <td>2</td>
      <td>10</td>
      <td>18</td>
      <td>0</td>
    </tr>
    <tr>
      <th>6.0</th>
      <td>0</td>
      <td>14</td>
      <td>9</td>
      <td>2</td>
      <td>3</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>7.0</th>
      <td>0</td>
      <td>5</td>
      <td>1</td>
      <td>2</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>8.0</th>
      <td>0</td>
      <td>3</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>9.0</th>
      <td>0</td>
      <td>3</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>10.0</th>
      <td>0</td>
      <td>2</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>From the table we can see the most common case (N=<span class="output text_plain">3065</span>) is properties with one bedroom surrounded mostly by other properties with also only one bedroom. Similarly we also find out, for example, that the two properties with ten bedrooms in the dataset are surrounded by properties with mostly two bedrooms. The remaining cells in the table can be interpreted in a similar fashion.</p>
<p>If more complicated statistics are required, it can help to reexpress the construction of summary statistics as a <em>reduction</em> of the <em>adjacency list</em> representation of our weights, as done in <a class="reference internal" href="04_spatial_weights.html"><span class="doc std std-doc">Chapter 4</span></a>. To recap, the <em>adjacency list</em> is a <code class="docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code> where each row contains a single link in our graph. It contains the identifier for some <code class="docutils literal notranslate"><span class="pre">focal</span></code> observation, the identifier for some <code class="docutils literal notranslate"><span class="pre">neighbor</span></code> observation, and a value for the <code class="docutils literal notranslate"><span class="pre">weight</span></code> of the link that connects the <code class="docutils literal notranslate"><span class="pre">focal</span></code> and <code class="docutils literal notranslate"><span class="pre">neighbor</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">adjlist</span> <span class="o">=</span> <span class="n">d500_w</span><span class="o">.</span><span class="n">to_adjlist</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">adjlist</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>focal</th>
      <th>neighbor</th>
      <th>weight</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>136</td>
      <td>0.023256</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0</td>
      <td>279</td>
      <td>0.023256</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0</td>
      <td>317</td>
      <td>0.023256</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0</td>
      <td>616</td>
      <td>0.023256</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0</td>
      <td>761</td>
      <td>0.023256</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>If we had the values for each for the neighbors in this adjacency list table, then we could use a <code class="docutils literal notranslate"><span class="pre">groupby()</span></code> to summarize the values of observations connected to a given focal observation. This merge can be done directly with the original data, linking the <code class="docutils literal notranslate"><span class="pre">neighbor</span></code> key in the adjacency list back to that observation in our source table:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">adjlist</span> <span class="o">=</span> <span class="n">adjlist</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
    <span class="n">airbnbs_albers</span><span class="p">[[</span><span class="s2">&quot;bedrooms&quot;</span><span class="p">]],</span>
    <span class="n">left_on</span><span class="o">=</span><span class="s2">&quot;neighbor&quot;</span><span class="p">,</span>
    <span class="n">right_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">adjlist</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>focal</th>
      <th>neighbor</th>
      <th>weight</th>
      <th>bedrooms</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>136</td>
      <td>0.023256</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0</td>
      <td>279</td>
      <td>0.023256</td>
      <td>3.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0</td>
      <td>317</td>
      <td>0.023256</td>
      <td>2.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0</td>
      <td>616</td>
      <td>0.023256</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0</td>
      <td>761</td>
      <td>0.023256</td>
      <td>1.0</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>Now, we need only to group the adjacency list by the focal observation and summarize the <code class="docutils literal notranslate"><span class="pre">bedrooms</span></code> column to obtain the median number of bedrooms for each <code class="docutils literal notranslate"><span class="pre">focal</span></code> observation.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">adjlist</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;focal&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">bedrooms</span><span class="o">.</span><span class="n">median</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>focal
0       1.0
1       2.0
2       1.0
3       1.0
4       1.0
       ... 
6105    1.0
6106    1.0
6107    1.0
6108    1.0
6109    1.0
Name: bedrooms, Length: 6110, dtype: float64
</pre></div>
</div>
</div>
</div>
<p>Since the mean and/or mode are the most commonly used measures of central tendency, the <code class="docutils literal notranslate"><span class="pre">lag_spatial</span></code> and <code class="docutils literal notranslate"><span class="pre">lag_categorical</span></code> functions cover many of the required uses in practice.</p>
</section>
<section id="ring-buffer-features">
<h4>“Ring” buffer features<a class="headerlink" href="#ring-buffer-features" title="Permalink to this headline">#</a></h4>
<p>Sometimes, analysts might want to use multiple “bands” of buffer features. This requires that we build summaries of the observations that fall <em>only within</em> a given range of distances, such as the typical size of houses that are further than 500 meters, but still within one kilometer. This kind of “ring buffer”, or annulus, is a common request in spatial analysis, and can be done in substantially the same way as before by increasing the <code class="docutils literal notranslate"><span class="pre">threshold</span></code> in a <code class="docutils literal notranslate"><span class="pre">DistanceBand</span></code> weight.</p>
<p>We can use our 500 meters weights from before to build the average again:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">average_within_500</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">lag_spatial</span><span class="p">(</span>
    <span class="n">d500_w</span><span class="p">,</span> <span class="n">airbnbs_albers</span><span class="p">[[</span><span class="s2">&quot;bedrooms&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Then, we need to build the graph of Airbnbs that fall <em>between</em> 500 meters and 1 kilometer from one another. To start, we build the <code class="docutils literal notranslate"><span class="pre">DistanceBand</span></code> graph of all listings closer than 1 kilometer:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">d1k_w</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">DistanceBand</span><span class="o">.</span><span class="n">from_dataframe</span><span class="p">(</span>
    <span class="n">airbnbs_albers</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">silence_warnings</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Then, using the <code class="docutils literal notranslate"><span class="pre">weights.set_operations</span></code> module, we can express set-theoretic relationships between graphs. Here, we need to <em>remove</em> the links in our 1 kilometer graph that are <em>also</em> links in the 500 meters graph. To do this, we need <code class="docutils literal notranslate"><span class="pre">w_difference(d1k_w,</span> <span class="pre">d500_w)</span></code>, the difference between the one kilometer graph and the 500 meters graph:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">d1k_exclusive</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">set_operations</span><span class="o">.</span><span class="n">w_difference</span><span class="p">(</span>
    <span class="n">d1k_w</span><span class="p">,</span> <span class="n">d500_w</span><span class="p">,</span> <span class="n">constrained</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>/opt/conda/lib/python3.10/site-packages/libpysal/weights/weights.py:172: UserWarning: The weights matrix is not fully connected: 
 There are 60 disconnected components.
 There are 32 islands with ids: 762, 907, 976, 1003, 1776, 1867, 2789, 2841, 3130, 3138, 3184, 3604, 3748, 3962, 3989, 4366, 4443, 4627, 4764, 4885, 4989, 5014, 5536, 5733, 5756, 5790, 5796, 5808, 6005, 6026, 6049, 6068.
  warnings.warn(message)
</pre></div>
</div>
</div>
</div>
<p>Then, we can compute the average size of listings between 500 meters and 1 kilometer in the same manner as before using our <code class="docutils literal notranslate"><span class="pre">d1k_exclusive</span></code> graph, which now omits all edges shorter than 500 meters.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">d1k_exclusive</span><span class="o">.</span><span class="n">transform</span> <span class="o">=</span> <span class="s2">&quot;r&quot;</span>
<span class="n">average_500m_to_1k</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">lag_spatial</span><span class="p">(</span>
    <span class="n">d1k_exclusive</span><span class="p">,</span> <span class="n">airbnbs_albers</span><span class="p">[[</span><span class="s2">&quot;bedrooms&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(&#39;WARNING: &#39;, 762, &#39; is an island (no neighbors)&#39;)
(&#39;WARNING: &#39;, 907, &#39; is an island (no neighbors)&#39;)
(&#39;WARNING: &#39;, 976, &#39; is an island (no neighbors)&#39;)
(&#39;WARNING: &#39;, 1003, &#39; is an island (no neighbors)&#39;)
(&#39;WARNING: &#39;, 1776, &#39; is an island (no neighbors)&#39;)
(&#39;WARNING: &#39;, 1867, &#39; is an island (no neighbors)&#39;)
(&#39;WARNING: &#39;, 2789, &#39; is an island (no neighbors)&#39;)
(&#39;WARNING: &#39;, 2841, &#39; is an island (no neighbors)&#39;)
(&#39;WARNING: &#39;, 3130, &#39; is an island (no neighbors)&#39;)
(&#39;WARNING: &#39;, 3138, &#39; is an island (no neighbors)&#39;)
(&#39;WARNING: &#39;, 3184, &#39; is an island (no neighbors)&#39;)
(&#39;WARNING: &#39;, 3604, &#39; is an island (no neighbors)&#39;)
(&#39;WARNING: &#39;, 3748, &#39; is an island (no neighbors)&#39;)
(&#39;WARNING: &#39;, 3962, &#39; is an island (no neighbors)&#39;)
(&#39;WARNING: &#39;, 3989, &#39; is an island (no neighbors)&#39;)
(&#39;WARNING: &#39;, 4366, &#39; is an island (no neighbors)&#39;)
(&#39;WARNING: &#39;, 4443, &#39; is an island (no neighbors)&#39;)
(&#39;WARNING: &#39;, 4627, &#39; is an island (no neighbors)&#39;)
(&#39;WARNING: &#39;, 4764, &#39; is an island (no neighbors)&#39;)
(&#39;WARNING: &#39;, 4885, &#39; is an island (no neighbors)&#39;)
(&#39;WARNING: &#39;, 4989, &#39; is an island (no neighbors)&#39;)
(&#39;WARNING: &#39;, 5014, &#39; is an island (no neighbors)&#39;)
(&#39;WARNING: &#39;, 5536, &#39; is an island (no neighbors)&#39;)
(&#39;WARNING: &#39;, 5733, &#39; is an island (no neighbors)&#39;)
(&#39;WARNING: &#39;, 5756, &#39; is an island (no neighbors)&#39;)
(&#39;WARNING: &#39;, 5790, &#39; is an island (no neighbors)&#39;)
(&#39;WARNING: &#39;, 5796, &#39; is an island (no neighbors)&#39;)
(&#39;WARNING: &#39;, 5808, &#39; is an island (no neighbors)&#39;)
(&#39;WARNING: &#39;, 6005, &#39; is an island (no neighbors)&#39;)
(&#39;WARNING: &#39;, 6026, &#39; is an island (no neighbors)&#39;)
(&#39;WARNING: &#39;, 6049, &#39; is an island (no neighbors)&#39;)
(&#39;WARNING: &#39;, 6068, &#39; is an island (no neighbors)&#39;)
</pre></div>
</div>
</div>
</div>
<p>Thus, as we can see in Figure XXX15XXX (generated by the code below), the two features contain distinct, but related, information, and both may be valuable in their own right when attempting to predict outcomes of interest.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Plot scatter</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
    <span class="n">average_within_500</span><span class="p">,</span> <span class="n">average_500m_to_1k</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;.&quot;</span>
<span class="p">)</span>
<span class="c1"># Rename horizontal axis</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Average size within 500 meters&quot;</span><span class="p">)</span>
<span class="c1"># Rename vertical axis</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Average size</span><span class="se">\n</span><span class="s2"> beyond 500m but within 1km&quot;</span><span class="p">)</span>
<span class="c1"># Plot line of 45 degrees</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
    <span class="n">color</span><span class="o">=</span><span class="s2">&quot;orangered&quot;</span><span class="p">,</span>
    <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;:&quot;</span><span class="p">,</span>
    <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">label</span><span class="o">=</span><span class="s2">&quot;1 to 1&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="c1"># Add legend</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/e36076d7a867c3d96710f228b8abbb16e0b4261d20cd1c4b930645e5b59daa71.png" src="../_images/e36076d7a867c3d96710f228b8abbb16e0b4261d20cd1c4b930645e5b59daa71.png" />
</div>
</div>
<p>As the plot shows, although the relationship between both is positive, there is quite a bit of variation and departure from the (red) line of equality. These represent cases with either larger (above the line) or smaller (below) average size in the 500 meters to 1 kilometer ring than in the 500 meters buffer.</p>
</section>
</section>
<section id="clustering-as-feature-engineering">
<h3>Clustering as feature engineering<a class="headerlink" href="#clustering-as-feature-engineering" title="Permalink to this headline">#</a></h3>
<p>One unique way to use spatial or features information <em>within</em> your data as a feature in your existing models is to use <em>clustering</em>, as we saw in Chapters <a class="reference internal" href="08_point_pattern_analysis.html"><span class="doc std std-doc">8</span></a> and <a class="reference internal" href="10_clustering_and_regionalization.html"><span class="doc std std-doc">10</span></a>, respectively. This can provide an indication of whether an observation exists in a given “place” geographically, or if an observation is a specific “kind” of observation. Data reduction of many variates into a derived categorical feature can be useful in training models. This is even more useful when the <em>spatial location</em> of a given observation indicates a useful characteristic about the kind of observation that may be found at that location.</p>
<p>While sometimes we might prefer to introduce space and (co-)location through our model (as we did in <a class="reference internal" href="11_regression.html"><span class="doc std std-doc">Chapter 11</span></a>), others we can instead use (spatial) cluster labels themselves as features. For example, to cluster the listings based on their location, we can use hierarchical DBSCAN <span id="id5">[<a class="reference internal" href="references.html#id5" title="Ricardo JGB Campello, Davoud Moulavi, and Jörg Sander. Density-based clustering based on hierarchical density estimates. In Pacific-Asia conference on knowledge discovery and data mining, 160–172. Springer, 2013.">CMS13</a>]</span>, an improved variant of the traditional DBSCAN algorithm used in <a class="reference internal" href="08_point_pattern_analysis.html"><span class="doc std std-doc">Chapter 8</span></a>. We import it through its own package <span id="id6">[<a class="reference internal" href="references.html#id78" title="Leland McInnes, John Healy, and Steve Astels. Hdbscan: hierarchical density based clustering. Journal of Open Source Software, 2(11):205, 2017.">MHA17</a>]</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">hdbscan</span> <span class="kn">import</span> <span class="n">HDBSCAN</span>
</pre></div>
</div>
</div>
</div>
<p>To apply to our Airbnb data, we need the coordinates as a two-dimensional array of XY pairs:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">coordinates</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">column_stack</span><span class="p">(</span>
    <span class="p">(</span><span class="n">airbnbs_albers</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">airbnbs_albers</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>With a little tuning, we can decide on an effective parameterization. The main advantage of HDBSCAN over the traditional approach is that it reduces the number of tuning parameters from two to one: we only need to set the minimum number of observations we want to define a cluster. Here, we look for relatively large clusters of Airbnbs, those with about 25 listings or more, fit them to our array of coordinates, and store the cluster labels identified:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">labels</span> <span class="o">=</span> <span class="n">HDBSCAN</span><span class="p">(</span><span class="n">min_cluster_size</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span><span class="o">.</span><span class="n">labels_</span>
</pre></div>
</div>
</div>
</div>
<p>The spatial distribution of these clusters will give us a sense of areas of San Diego with relatively high density of the observations. But the <code class="docutils literal notranslate"><span class="pre">labels</span></code> object does not contain clusters, only observation memberships. To derive those clusters geographically, we construct the convex hull of the observations in each detected cluster, creating thus a polygon that delimits every observation that is part of the cluster:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">hulls</span> <span class="o">=</span> <span class="n">airbnbs_albers</span><span class="p">[[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">dissolve</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="n">labels</span><span class="p">)</span><span class="o">.</span><span class="n">convex_hull</span>
</pre></div>
</div>
</div>
</div>
<p>The polygons in <code class="docutils literal notranslate"><span class="pre">hulls</span></code> (and displayed in Figure XXX16XXX) provide an intermediate layer between the granularity of each individual location and the global scale of San Diego as a geographical unit. Since people tend to make locational decisions hierarchically (e.g., first they select <em>San Diego</em> as a destination, then they pick a particular <em>part</em> of San Diego, then choose a house within the area), this approach might give us reasonable insight into enclaves of Airbnb properties:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set up figure and axis</span>
<span class="n">f</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">))</span>
<span class="c1"># Plot individual Airbnb locations</span>
<span class="n">airbnbs_albers</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
    <span class="c1"># Color by cluster label</span>
    <span class="n">column</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span>
    <span class="c1"># Consider label as categorical</span>
    <span class="n">categorical</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="c1"># Add 50% of transparency</span>
    <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
    <span class="c1"># Include legend</span>
    <span class="n">legend</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="c1"># Draw on axis `ax`</span>
    <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
    <span class="c1"># Use circle as marker</span>
    <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">,</span>
    <span class="c1"># Position legend outside the map</span>
    <span class="n">legend_kwds</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;bbox_to_anchor&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)},</span>
<span class="p">)</span>
<span class="c1"># Plot convex hull polygons for each cluster label</span>
<span class="c1"># except that for -1 (observations classified as noise)</span>
<span class="n">hulls</span><span class="p">[</span><span class="n">hulls</span><span class="o">.</span><span class="n">index</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">boundary</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
<span class="c1"># Add basemap</span>
<span class="n">contextily</span><span class="o">.</span><span class="n">add_basemap</span><span class="p">(</span>
    <span class="n">ax</span><span class="p">,</span>
    <span class="n">crs</span><span class="o">=</span><span class="n">airbnbs_albers</span><span class="o">.</span><span class="n">crs</span><span class="o">.</span><span class="n">to_string</span><span class="p">(),</span>
    <span class="n">source</span><span class="o">=</span><span class="n">contextily</span><span class="o">.</span><span class="n">providers</span><span class="o">.</span><span class="n">CartoDB</span><span class="o">.</span><span class="n">VoyagerNoLabels</span><span class="p">,</span>
<span class="p">)</span>
<span class="c1"># Remove axes</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/2a1ebc173232db6d6e0ddc5ed357c771ebbf0072fd51f77cccf0abbba068bf25.png" src="../_images/2a1ebc173232db6d6e0ddc5ed357c771ebbf0072fd51f77cccf0abbba068bf25.png" />
</div>
</div>
<p>Note how the hierarchical nature of HDBSCAN, which picks density thresholds <em>locally</em> is at work in the map, where some of the clusters (e.g., orange ones in the north) display lower density than parts of the center which are <em>not</em> part of any cluster. These results also capture some information about the price of a listing. Figure XXX17XXX (generated with the code below) shows this by plotting the distribution of prices across the detected clusters.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set up figure</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="c1"># Add boxplots of price by HDBSCAN cluster</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">airbnbs_albers</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">)</span><span class="o">.</span><span class="n">boxplot</span><span class="p">(</span>
    <span class="c1"># Plot distribution of &#39;price&#39;</span>
    <span class="s2">&quot;price&quot;</span><span class="p">,</span>
    <span class="c1"># Group by cluster label, generating one boxplot/cluster</span>
    <span class="n">by</span><span class="o">=</span><span class="s1">&#39;labels&#39;</span><span class="p">,</span>
    <span class="c1"># Do not display individual outlier observations</span>
    <span class="n">flierprops</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">marker</span><span class="o">=</span><span class="kc">None</span><span class="p">),</span>
    <span class="c1"># Draw visualization on the current axis (inside `f`)</span>
    <span class="n">ax</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">(),</span>
<span class="p">)</span>
<span class="c1"># Set label for horizontal axis</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;HDBSCAN cluster&quot;</span><span class="p">)</span>
<span class="c1"># Set labels for vertical axis</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;price ($)&quot;</span><span class="p">)</span>
<span class="c1"># Remove default figure title</span>
<span class="n">plt</span><span class="o">.</span><span class="n">gcf</span><span class="p">()</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="c1"># Remove default axis title</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="c1"># Re-adjust vertical value range for easier legibility</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1250</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/1d87467adf8c0d8642cd9f1a3f036d085e60af86b17633239f9abda2a1713645.png" src="../_images/1d87467adf8c0d8642cd9f1a3f036d085e60af86b17633239f9abda2a1713645.png" />
</div>
</div>
<p>If we want to capture the variation picked up by membership to these clusters in a regression model, we could use these labels as the basis for spatial fixed effects, for example, as we saw in <a class="reference internal" href="11_regression.html"><span class="doc std std-doc">Chapter 11</span></a>.</p>
</section>
</section>
<section id="conclusion">
<h2>Conclusion<a class="headerlink" href="#conclusion" title="Permalink to this headline">#</a></h2>
<p>Feature engineering is a powerful way to enrich your data and make the most out of them. It is often within reach whether you are able to mix in auxilliary data or not. At a minimum, it only requires that new variables are constructed from your existing data; however, if you have access to more data, spatial feature engineering provides the <em>ultimate linkage key</em>, a flexible and powerful tool with which you can unlock the value held in many <em>other</em> datasets that you may have access to even if they are not obviously connected to your own.</p>
<p>We have structured all the approaches presented in this chapter along two main groups: those which allow you to augment a given dataset, which we have termed <em>map synthesis</em>; and those that enable connecting disparate datasets through space. In both cases, each operation involved in feature engineering, such as determining what the average value is in the area near each observation or identifying whether observations exist as part of a “cluster”, are relatively simple operations. As building blocks that may be combined with each other, they build large, rich, and useful datasets that can be used directly in your existing methods of analysis.</p>
<p>Beyond feature engineering, statistical techniques we discuss in this book (particularly in Chapters <a class="reference internal" href="10_clustering_and_regionalization.html"><span class="doc std std-doc">10</span></a> and <a class="reference internal" href="11_regression.html"><span class="doc std std-doc">11</span></a>) can leverage spatial structure <em>directly</em> during learning/inference. These techniques allow you to embed space in non-spatial models to make them “geography aware”. Furthermore, the techniques in this chapter (and the methods that extend upon them) are immediately useful for most practicing data scientists, and they can be integrated into nearly any analytical method or approach.</p>
</section>
<section id="questions">
<h2>Questions<a class="headerlink" href="#questions" title="Permalink to this headline">#</a></h2>
<ol class="arabic simple">
<li><p>Thinking of your own research, provide an example where map matching would
be a useful spatial feature engineering approach? How about an example where
map synthesis would be useful for your research?</p></li>
<li><p>In the <span class="xref myst">Counting <em>nearby</em> features</span> example early in the chapter, there
is a potential issue with under-counting the number of nearby bars and
restaurants for certain Airbnbs in the dataset. Which Airbnbs are subject to
neighbor under-counts and why?</p></li>
<li><p>How would you correct the under-count in the previous question?</p></li>
<li><p>Dasymetric mapping may introduce spurious spatial autocorrelation (see
Chapters <a class="reference internal" href="06_spatial_autocorrelation.html"><span class="doc std std-doc">6</span></a> and <a class="reference internal" href="07_local_autocorrelation.html"><span class="doc std std-doc">7</span></a>) through
the interpolation process. How does this occur and why is it important to acknowledge?</p></li>
<li><p>From the previous spatial regression chapter, is the SLX model a map matching or a map synthesis technique?</p></li>
<li><p>Feature engineering can be used in many different applied contexts. When might feature engineering actually <em>not</em> improve a model?</p></li>
</ol>
</section>
<section id="next-steps">
<h2>Next steps<a class="headerlink" href="#next-steps" title="Permalink to this headline">#</a></h2>
<p>For more information on machine learning methods, it is difficult to beat <em>Introduction to Statistical Learning</em> by:</p>
<p>James, Gareth, Daniela Witten, Trevor Hastie, and Robert Tibshirani. 2021. <em>Introduction to Statistical Learning</em> (2nd Edition). Wiley: New York.</p>
<p>In addition, there are many geospatial relationships that can be leveraged to merge datasets together. These <em>spatial join</em> techniques often require quite a bit of background understanding in <em>geocomputation</em>, computation that focuses on the basic/fundamental geometric operations and relationships between geographic objects. However, simple introductions are offered by our partner book:</p>
<p>Tenkanen, Henrikki, Vuokko Heikinheimo, and David Whipp. 2023. <em>Python for Geographic Data Analysis</em>. CRC Press: Boca Raton, FL. <a class="reference external" href="https://pythongis.org">https://pythongis.org</a></p>
<p>Finally, references on geographic interpolation methods are sometimes hard to come by, but a good and readable introduction to the domain is offered by:</p>
<p>Comber, Alexis and Wen Zeng. 2019. “Spatial Interpolation using areal features: A review of methods and opportunities using new forms of data with coded illustrations.” <em>Geography Compass</em> 13.  <a class="reference external" href="https://doi.org/10.1111/gec3.12465">https://doi.org/10.1111/gec3.12465</a></p>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./notebooks"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="11_regression.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Spatial Regression</p>
      </div>
    </a>
    <a class="right-next"
       href="references.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">References</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#what-is-spatial-feature-engineering">What is spatial feature engineering?</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#feature-engineering-using-map-matching">Feature engineering using map matching</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#counting-nearby-features">Counting <em>nearby</em> features</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#assigning-point-values-from-surfaces-elevation-of-airbnbs">Assigning point values from surfaces: elevation of Airbnbs</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#point-interpolation-using-scikit-learn">Point interpolation using scikit-learn</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#polygon-to-point">Polygon to point</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#area-to-area-interpolation">Area to area interpolation</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#feature-engineering-using-map-synthesis">Feature engineering using map synthesis</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#spatial-summary-features-in-map-synthesis">Spatial summary features in map synthesis</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#counting-neighbors">Counting neighbors</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#distance-buffers-within-a-single-table">Distance buffers within a single table</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#ring-buffer-features">“Ring” buffer features</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#clustering-as-feature-engineering">Clustering as feature engineering</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#conclusion">Conclusion</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#questions">Questions</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#next-steps">Next steps</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Sergio J. Rey, Dani Arribas-Bel, Levi J. Wolf
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      © Copyright 2020.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
<div class="extra_footer">
  <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.

</div>
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>